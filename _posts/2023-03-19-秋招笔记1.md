### Markdown语法

* 换页

  ```<div STYLE="page-break-after: always;"></div>```

* 常见语法

  ```
  Markdown 目录：
  [TOC]
  
  Markdown 标题：
  # 这是 H1
  ## 这是 H2
  ### 这是 H3
  
  Markdown 列表：
  - 列表项目
  1. 列表项目
  
  *斜体*或_斜体_
  **粗体**
  ***加粗斜体***
  ~~删除线~~
  
  Markdown 插入链接：
  [链接文字](链接网址 "标题")
  
  ## 目录
  1. [标题1](#标题1)
  
  ...
  ...
  ### 标题1
  链接当前文档的标题：
  
  Markdown 插入图片：
  ![alt text](/path/to/img.jpg "Title")
  
  Markdown 插入代码块：
      ```python
      #!/usr/bin/python3
      print("Hello, World!");
  ```
  
  Markdown 引用：
  > 引用内容
  
  Markdown 分割线：
  ---
  
  Markdown 换行：
  <br>
  
  Markdown 段首缩进：
  &ensp; or &#8194; 表示一个半角的空格
  &emsp; or &#8195;  表示一个全角的空格
  &emsp;&emsp; 两个全角的空格（用的比较多）
  &nbsp; or &#160; 不断行的空白格
  
  ```





<div STYLE="page-break-after: always;"></div>

### Linux常用命令

#### Linux保存服务器密码

scp ~/.ssh/id_rsa.pub -p 1022 root@139.196.175.238:~/.ssh/authorized_keys

Fxm#NT-xBVqwKr3

...............................................................110.53.180.21



```
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
git config --global credential.helper store
git config --global credential.helper cache
```



#### Linux 显示文件及文件夹数量

![image-20211025131016105](/home/zhoubing/.config/Typora/typora-user-images/image-20211025131016105.png)

#### Linux服务器访问数据

![image-20211025202048200](/home/zhoubing/.config/Typora/typora-user-images/image-20211025202048200.png)



#### ln 命令

![image-20211112180836015](/home/zhoubing/.config/Typora/typora-user-images/image-20211112180836015.png)





#### Tmux命令





![2021-08-20 21-49-26屏幕截图](/home/zhoubing/Pictures/2021-08-20 21-49-26屏幕截图.png)





#### mv命令 

![image-20210831131329574](/home/zhoubing/.config/Typora/typora-user-images/image-20210831131329574.png)





#### Bash 脚本命令

![image-20211230154455065](/home/zhoubing/.config/Typora/typora-user-images/image-20211230154455065.png)














<div STYLE="page-break-after: always;"></div>





### nn.Module

![image-20210929150111473](/home/zhoubing/.config/Typora/typora-user-images/image-20210929150111473.png)



<div STYLE="page-break-after: always;"></div>



### 时间复杂度

![image-20211004155919613](/home/zhoubing/.config/Typora/typora-user-images/image-20211004155919613.png)

![数据范围2.jpg](https://cdn.acwing.com/media/article/image/2020/02/05/3019_ca300f8448-%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B42.jpg)



![image-20211127215804687](/home/zhoubing/.config/Typora/typora-user-images/image-20211127215804687.png)



![image-20211127215859228](/home/zhoubing/.config/Typora/typora-user-images/image-20211127215859228.png)





### 空间复杂度

* 二维数组最多开到 ： `a[1e4][1e4]`
* 一维数组最多开到 ： `a[1e8]`  如果想存比较大的数据可以使用： map容器





<div STYLE="page-break-after: always;"></div>

### Chrome快捷键



![preview](https://pic2.zhimg.com/59510298389d8abfc74b26f0f688c176_r.jpg?source=1940ef5c)



>shift+w。当前标签页切换为一个新的任务窗口
>
>ctrl + w：关闭当前标签页（需要记忆的**第一个**快捷键）
>ctrl + t：打开新标签页（需要记忆的**第二个**快捷键）
>alt + d：转到地址栏（需要记忆的**第三个**快捷键）
>ctrl + f：查找关键字（需要记忆的**第四个**快捷键）



<div STYLE="page-break-after: always;"></div>

### vscode快捷键

> vscode setting sync gist: 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

* vscode 快捷键：

  > Shift+Alt+D 下载配置
  >
  > 快捷键 Shift+Alt+U(上传)/D(下载)

* leetcode完全背包小结：

  > 组合数：外层for循环遍历的是物品数，内存for循环遍历的是背包容量，均是正序遍历，理解方法：物品总是从1....n出现是有序的，eg:(1,5)会出现，(5,1)就不会出现
  >
  > 排列数：外层for循环遍历的是背包容量，内循环遍历的是物品数量，与上面相反，均是正序遍历，理解方法：物品遍历在内循环，可能出现物体顺序混乱的情况，eg:(1,5)和(5,1)均可能出现

* koroFileHeader插件：

  > **在光标处添加函数注释**:快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t,linux: ctrl+meta+t meta就是键盘的win视窗键


* vscode同时编辑修改所选中的所有变量名称：

  > 1.Crtl+F 找到需要修改的变量
  >
  > 2.Crtl+shift+L 选中所有查找的变量，然后删除就可以了



<div STYLE="page-break-after: always;"></div>



### 二分模板

![image-20211017165643874](/home/zhoubing/.config/Typora/typora-user-images/image-20211017165643874.png)

![image-20211017172820091](/home/zhoubing/.config/Typora/typora-user-images/image-20211017172820091.png)

[二分查找详细讲解](https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/)

![image-20211017173930671](/home/zhoubing/.config/Typora/typora-user-images/image-20211017173930671.png)

> 二分查找无论任何情况一定是：left=mid+1.
>
> 当左闭右闭的时候【】：right=mid-1
>
> 左闭右开的时候【）：right=mid
>
> 原因是，我们下一次遍历的区间范围需要和原始的闭合情形保持一致，但是都需要将mid这个位置的元素排除在外！！！

<div STYLE="page-break-after: always;"></div>

* **寻找左边界是包含 r 这个位置的数据的，但是求右边界 l 是不会包含右边界的这个数据的！**
* 任何一个左边界都是会包括的，在最终退出循环的时候，但是任何的右边界都是不会包含的，在最后退出的时候，因为需要 l + 1



<div STYLE="page-break-after: always;"></div>

### Git

#### 代理

![image-20211020204019844](/home/zhoubing/.config/Typora/typora-user-images/image-20211020204019844.png)

![image-20211020204035623](/home/zhoubing/.config/Typora/typora-user-images/image-20211020204035623.png)



#### Clone 别人仓库上传到自己仓库

![image-20211020205110570](/home/zhoubing/.config/Typora/typora-user-images/image-20211020205110570.png)

![image-20211028224903128](/home/zhoubing/.config/Typora/typora-user-images/image-20211028224903128.png)



* Git add相关操作，将其加入到本地缓存的相关操作

  ![image-20211029165938316](/home/zhoubing/.config/Typora/typora-user-images/image-20211029165938316.png)

#### Git 基本命令图

![image-20211230210500038](/home/zhoubing/.config/Typora/typora-user-images/image-20211230210500038.png)



#### git commit 到错误分支

```shell
#回退到上个版本
git reset HEAD~ --soft
#暂存未提交文件
git stash
#切换(或新建)到你期望的分支
git checkout your-correct-branch
#重新应用缓存的stash
git stash pop

```











<div STYLE="page-break-after: always;"></div>



<div STYLE="page-break-after: always;"></div>





### 代码风格指南

#### GOOGLE变量命名

* 命名要有描述性，尽量少使用缩写

* 文件命名

  > 文件命名要求全部小写，可以包含下划线：my_useful_class.cc

* 类型命名

  >类型命名：类、结构体、类型定义(typedef)、枚举、类型模板参数
  >
  >规则：每个单词字母均大写，不包含下划线: MyExcitingClass

* 变量命名

  > 变量定义：变量（包含函数参数）和数据成员名
  >
  > 规则：一律使用小写，单词之间使用下划线连接，**类的成员变量以下划线结尾**，但是**结构体不需要下划线**结尾：a_local_variable,a_struct_data_memeber,a_class_data_memeber_,

  ![image-20211103000333025](/home/zhoubing/.config/Typora/typora-user-images/image-20211103000333025.png)![image-20211103000351797](/home/zhoubing/.config/Typora/typora-user-images/image-20211103000351797.png)

* 常量命名

  > 声明为constexpr或const的变量，或在程序运行期间值始终保持不变的，命名时以"k"开头，大小写混合，例如：
  >
  > ```
  > const int kDaysInAWeek=7
  > ```

* 函数命名

  > 常规的函数使用的是大小写混写，取值和设值函数则是要求与变量名匹配：MyExcitingFunction(),MyExcitingMethod(),set_my_exciting_memeber_variable().
  >
  > 一般来说：函数名的每个单词的首字母大写，没有下划线（驼峰变量名）
  >
  > 同样的命名规则同时适用于类作用域和命名空间作用域的常量，因为它们作为API的一部分暴露在外，我们可以将其看做是一个函数
  >
  > 取值函数命名域变量一致的原理：`int count(),int set_count(int count)`

* 命名空间namespace命名：

  > 命名空间使用小写命名，最高级的命名空间名称取决于项目的名称，要注意嵌套命名空间以及常见的顶级命名空间的名字之间发生冲突

* 枚举命名

  > 枚举的命名应当和**常量**const 或者**宏**一致：`kEnumName`或者是`ENUM_NAME`
  >
  > 说明：单独的枚举优先使用常量的命名方式：

  ![image-20211103002701031](/home/zhoubing/.config/Typora/typora-user-images/image-20211103002701031.png)

* 空行：而是要多用空格分隔开变量与操作符，用**空行分隔开代码块**，保持适当的阅读节奏。

* ```cpp
  
  if (!value.contains("xxx")) {                    // if后{前有空格
        LOGIT(WARNING, "value is incomplete.\n")        // 逗号后有空格
        return;                                      // 逻辑联系紧密就不用加空行
  }
                                                    // 新增空行分隔段落
  char suffix[16] = "xxx";                          // 等号两边有空格
  int data_len = 100;                            // 逻辑联系紧密就不用加空行
                                                    // 新增空行分隔段落
  if (!value.empty() && value.contains("tom")) {   // &&两边有空格
      const char* name = value.c_str();              // 等号两边有空格
                                                        // 新增空行分隔段落
      for(int i = 0; i < MAX_LEN; i++){              // =;<处有空格
          ...  // do something
    	}
                                                    // 新增空行分隔段落
    	int count = 0;                                  // 等号两边有空格
                                                    // 新增空行分隔段落
    	for(int i = 0; i < strlen(name); i++){          // =;<处有空格
      	... // do something  
   	}
  }
  ```

* 变量、函数名和名字空间用 snake_case，**全局变量加“g_”前缀；_**

* 自定义类名用 **CamelCase**，成员函数用 snake_case，成员变量加“m_”前缀；_

* **宏和常量应当全大写**，单词之间用下划线连接；

* 尽量**不要用下划线作为变量的前缀或者后缀**（比如 _local、name_），很难识别。

```cpp

#define  MAX_PATH_LEN  256             //常量，全大写

int g_sys_flag;                        // 全局变量，加g_前缀

namespace linux_sys {                // 名字空间，全小写
  void get_rlimit_core();               // 函数，全小写
}

class FilePath final                 // 类名，首字母大写
{
public:
  void set_path(const string& str);    // 函数，全小写
private:  
  string m_path;                      // 成员变量，m_前缀 
  int    m_level;                     // 成员变量，m_前缀
};

```

![img](https://static001.geekbang.org/resource/image/3a/41/3a5325510a8c10a318f82f9ac2696941.jpg?wh=2284*2457)



#### 中文写作指南

**参考的链接： [stdrc](https://stdrc.cc/style-guides/chinese#)**

* 中英文之间空格

> 在 Python 中，我们使用 `class` 关键字来声明类。

* 中文和数字之间空格

> 他只用了 100 行不到的代码就实现了那个复杂的功能。

* 数字与英文单位之间加空格、与符号单位之间不加空格

> 我有一块 512 GB 的硬盘。
>
> 今天气温 23˚C，有 70% 的可能性下雨。

* 全角标点与其它字符之间不加空格

> 他有一台 Mac。

* 中文与英文半角符号之间加空格

> 很多人都在学习 C++ 这门语言。
>
> count-- 表示给 count 变量减 1。

* 行的开头和结尾不应出现空白字符

> 错误做法：
>
> ..这是一行文字。..
>
> （上面的「.」表示空格）

* 不要出现连续的两个空格的出现
* 链接和文字之间要加一个空格

> 如需下载，请点击 [这里](https://stdrc.cc/style-guides/chinese#)。

* 书名、篇名、报纸名、杂志名、歌曲名、影剧名和图表名，用书名号标识，括号用作注明翻译或原文时应置于书名号外。

> 《旺达与巨像》（Shadow of the Colossus）好玩吗？









<div STYLE="page-break-after: always;"></div>

### C++基本语法



![2021-11-08_22-37](/home/zhoubing/Pictures/2021-11-08_22-37.png)



#### Operator

![image-20211116230255706](/home/zhoubing/.config/Typora/typora-user-images/image-20211116230255706.png)



#### Const

![image-20211118000149318](/home/zhoubing/.config/Typora/typora-user-images/image-20211118000149318.png)



#### Copy constructor && copy assignment

![image-20211118004030551](/home/zhoubing/.config/Typora/typora-user-images/image-20211118004030551.png)

* 上面是没法工作的！！！

![image-20211118004318532](/home/zhoubing/.config/Typora/typora-user-images/image-20211118004318532.png)

* 需要这样写！！！
* 原因：

> 因为，当我们跳出这个作用域的时候，我们会执行析构函数，释放这个变量，所以我们需要拷贝一个副本，防止跳出循环释放了这个变量，这样我们指向的那个变量被释放了，我们依旧有一个合法的返回，因为 return value ,也会执行一个拷贝构造函数



#### lvalue && rvalue 

![image-20211118142300281](/home/zhoubing/.config/Typora/typora-user-images/image-20211118142300281.png)



![image-20211118151952393](/home/zhoubing/.config/Typora/typora-user-images/image-20211118151952393.png)



#### 继承

![image-20211118222437663](/home/zhoubing/.config/Typora/typora-user-images/image-20211118222437663.png)

![image-20211118222730042](/home/zhoubing/.config/Typora/typora-user-images/image-20211118222730042.png)

![image-20211118233955164](/home/zhoubing/.config/Typora/typora-user-images/image-20211118233955164.png)





#### 内存管理

![image-20211120143111822](/home/zhoubing/.config/Typora/typora-user-images/image-20211120143111822.png)



![image-20211120143425141](/home/zhoubing/.config/Typora/typora-user-images/image-20211120143425141.png)

* 当定义的局部变量出了作用域，或者说出了函数体之后，就会自动调用析构函数，释放这个资源，不需要程序要手动写一段代码显示的释放资源了。
* lock_guard<mutex>(databaseLock)            : lock always unlocked when function exists.

#### samrt pointer

![image-20211120145813019](/home/zhoubing/.config/Typora/typora-user-images/image-20211120145813019.png)

##### unique pointer

![image-20211120150315300](/home/zhoubing/.config/Typora/typora-user-images/image-20211120150315300.png)

##### shared_ptr



![image-20211120151510213](/home/zhoubing/.config/Typora/typora-user-images/image-20211120151510213.png)





#### 强制类型转换(C++)

* reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位。

![image-20211121182516069](/home/zhoubing/.config/Typora/typora-user-images/image-20211121182516069.png)





#### Compile time vs. Runtime

![image-20211121215957087](/home/zhoubing/.config/Typora/typora-user-images/image-20211121215957087.png)



![image-20211121220013555](/home/zhoubing/.config/Typora/typora-user-images/image-20211121220013555.png)

![image-20211121220836046](/home/zhoubing/.config/Typora/typora-user-images/image-20211121220836046.png)

#### Lambda 并查集Find写法

![image-20211126151212409](/home/zhoubing/.config/Typora/typora-user-images/image-20211126151212409.png)



#### regex正则表达式

![image-20211126171933064](/home/zhoubing/.config/Typora/typora-user-images/image-20211126171933064.png)



#### 虚函数

[虚函数表详解](https://zhuanlan.zhihu.com/p/75172640)

![image-20211207011322232](/home/zhoubing/.config/Typora/typora-user-images/image-20211207011322232.png)



![preview](https://pic3.zhimg.com/v2-dfe4aefdee7e06cf3151b57492ed42a2_r.jpg)



![preview](https://pic2.zhimg.com/v2-0fceb07713e411d48b4c361452129585_r.jpg)



#### const *  && * cosnt

```
char greeting[] = "Hello"
char* p = greeting;                                   // non-const pointer, non-const data
const char* p = greeting;                             // non-const pointer, const data
char* const p = greeting;                             // const pointer, non-const data
const char* const p = greeting                        // const pointer, const data
```

* 如何判断是常量指针，还是常量数据

  > 如果关键字 const 出现在星号左边：`const*`，读作：常量指针，那么就是常量数据，表示的是被指向的物是常量，表示的是我们不能修改指向的数据，但是可以修改指向的指针
  >
  > 如果 const 出现在星号右边：`*const`，读作：指针常量，表示我们不能修改指向的地址，但是可以地址里面的数据

![image-20211210165535862](/home/zhoubing/.config/Typora/typora-user-images/image-20211210165535862.png)













### LeetCode刷题总结

#### 背包小结

* 如果求组合数（就是考虑物品的先后顺序），那么外层for循环遍历物品，内层for循环遍历背包容量
* 如果求排列数（不用考虑物品先后顺序），那么外层for循环遍历背包容量，内存for循环遍历物品
* 0-1背包使用滚动数组，我们背包容量，从后往前遍历，目的是：防止一个背包被多次遍历
* 完全背包：背包容量是从小到大遍历，目的是：一个背包就是可以多次的遍历

![image-20211128002538415](/home/zhoubing/.config/Typora/typora-user-images/image-20211128002538415.png)

* 0-1背包和完全背包的代码：

![image-20211128002639774](/home/zhoubing/.config/Typora/typora-user-images/image-20211128002639774.png)

#### 最短路径总结

![image-20211212155100130](/home/zhoubing/.config/Typora/typora-user-images/image-20211212155100130.png)

* SPFA 使用的是 queue，可能出现同一个节点多次进出队列，这个是允许的， 注意存储结构可以使用：链式前向星存储，比邻接表存储效率更高。dist[i] 只需要一维数组，因为，这里我们求得的是单源最短路径，这个 dist[i] 表示的是 i 节点，和起始节点的距离，所以可以只使用一维数组

* Dijkstra 算法：使用的是  `priority_queue<SNode>pq`  因为优先队里是优先输出大的数据，所以这里需要对 `<`  进行重载，使得按照距离小的节点先输出出去。其他的和 SPFA 算法差不太多

  ``` c++
  struct SNode {
      int id, dis;
      SNode(int id, int dis) : id(id), dis(dis) {}
      bool operator < (const SNode & a) const {  // 对优先级符号 < 重载，注意不能对大于号重载，因为 priority_queue 中排序是按照 < 优先级排序的
          return dis > a.dis;
      }
  };
  ```

* Floyd 三层 for 循环，最外层是 中间节点。

* 无权：直接BFS有权且权重非负Dijkstra： `O(mlogn)`
* 有权，权重包含负值，使用bellman-ford算法 `O(mn)`
* 有权，权重包含负值，可以用来判断是否具有负圈， 求不了包含负圈的最短路径 : `O(mn)`



##### SPFA

```c++
const int INF = 1e6;
const int NUM = 105;
struct Edge {
    int from, to, w;
    Edge(int a, int b, int c) : from(a), to(b), w(c) {}
};

vector<Edge>e[NUM];
int n, m;
int pre[NUM];  // 打印出路径，所以我们设置一个数组
int prev[NUM];

int spfa(int s) {
    // 如果求最短路径，我们需要定义哪些数组，首先第一个就是 dist[]数组,然后设置一个 inque[] 数组，用于判断是否进入过队列
    // 之后是一个 neg[] 数组，用于判断是否存在负圈
    int dis[NUM], inque[NUM], neg[NUM];
    std::memset(neg, 0, sizeof neg);
    for (int i = 1; i <= n; ++i) {
        dis[i] = INF;
        inque[i] = 0;
    }
    dis[s] = 0;
    inque[s] = 1;
    neg[s] = 1;
    std::queue<int>que;
    que.push(s);
    pre[s] = s;
    while (!que.empty()) {
        int from = que.front();
        que.pop();
        inque[from] = 0;
        for (int i = 0; i < e[from].size(); ++i) {
            int to = e[from][i].to, cost = e[from][i].w;
            if (dis[from] + cost < dis[to]) {
                dis[to] = dis[from] + cost;
                pre[to] = from;
                if (inque[to] == 0) {
                    inque[to] = 1;
                    que.push(to);
                    neg[to]++;
                    if (neg[to] >= n) return -1;  // 经过的边数大于等于 n 那么代表存在负环
                }
            }
        }
    }
    return dis[n];
}
```



##### Djkstra

```c++
int n, m;
const int kNum = 105;
const int kMaxn = 1e6;

struct Edge {
    int from, to, w;
    Edge(int from, int to, int w) : from(from), to(to), w(w) {}
};

struct SNode {
    int id, dis;
    SNode(int id, int dis) : id(id), dis(dis) {}
    bool operator < (const SNode & a) const {  // 对优先级符号 < 重载，注意不能对大于号重载，因为 priority_queue 中排序是按照 < 优先级排序的
        return dis > a.dis;
    }
};

int prev[kNum];
std::vector<Edge>e[kNum];

int Dijkstra(int s) {
    int dist[kNum];
    bool inque[kNum];  // 表示的是已近在 A 数组中，因为 Dijkstra 只要加入到数组中，那么就已近算是求出最短路径了
    for (int i = 0; i <= n; ++i) {
        dist[i] = kMaxn;
        inque[i] = 0;
    }
    prev[s] = s;
    dist[s] = 0;
    std::priority_queue<SNode>pq;
    pq.push(SNode(s, dist[s]));
    // inque[s] = 1;
    while (!pq.empty()) {
        auto front = pq.top();
        pq.pop();
        int id = front.id, dis = front.dis;
        if (inque[front.id]) continue;
        inque[front.id] = 1;
        for (int i = 0; i < e[id].size(); ++i) {
            int to = e[id][i].to;
            int cost = e[id][i].w;
            if (inque[to]) continue;
            if (dist[id] + cost < dist[to]) {
                dist[to] = dist[id] + cost;
                pq.push(SNode(to, dist[to]));
            }
        }
    }
    return dist[n];
}
```







#### DP - 子序列问题

##### 两个字符串，或者数组

* 通常采用的是 `i : 0 ~ n - 1, j : 0 ~ n - 1` 从小到大进行遍历的

  ```c++
  for (int i = 0; i < n; ++i) {
  	for (int j = 0; j < n; ++j) {
  		if (s[i] == s[j]) {
  			dp[i][j] = dp[i - 1][j - 1] + ...
  		} else {
  			dp[i][j] = max() / 0
  		}
  	}
  }
  ```

  

**注意，一定要观察dp数组是从哪个方向转移过来的，我们for循环 i 的变换方向就往那个方向变化**



##### 一个字符串，或者数组

* 通常是通过：**小区间 推导出 大区间**  ，所以 通常采用： 

  ```c++
  for (int len = 0; len < n; ++len) {
  	for (int l = 0; l + len < n; ++l) {
  		int r = l + len; // 数组右端
  		if () {
  			dp[l][r] = dp[][] + ...
  		} else {
  			dp[l][r] = dp[][] + ...
  		}
  		
  	}
  }
  ```

  进行求解的，通常递推只用到一半的二维数组空间

* 或者一个数组，我们通常利用之前已经求得的  `dp` 数组进行求解， 写法： 

  ```C++
  for (int i =0; i < n; ++i) {
  	for (int j = 0; j < i; ++j) {
  		if () {
  			dp[i] = dp[j] + ...
  		} else {
  			dp[i] = dp[] + ...
  		}
  	}
  }
  ```








#### 字符串删除相关 dp

* 首先：dp 两重循环都是从小到大： [1,n] 均闭合
* dp [i] [j] 表示的都是 s[i - 1] 和 t [j - 1] 位置字符串的状态
* dp [i] [j] 表示的是 删除所需要的次数， 或者 s[i - 1] 和 t[j - 1] 字符串相同字符的个数...

```c++
// 基本模板
s[m], t[n];
int dp[m + 1][n + 1];
// 初始化.
// 删除字符串初始化：
for (int i = 0; i <= m; i++) dp[i][0] = i;
for (int i = 0; i <= n; i++) dp[0][i] = i;

// s 子序列中 t 出现的次数
for (int i = 0; i <= m; i++) dp[i][0] = 1; // s 中一定出现空的字符串
for (int i = 1; i<= n; i++) dp[0][i] = 0; // 因为 s 为空， 所以 t 不空，一定不会出现在 s 中

// s 是否是 t 的子序列， dp[i][j] 返回的是 s[i - 1] t[j - 1] 为结尾的相同子序列长度
dp[i][j] = 0 // 在每一处都初始化为 0， 


// 主循环
for (int i = 1; i <= m; i++) {  // 注意一定是从 1 开始，从小到大
    for (int j = 1; j <= n; j++) {
        if (s[i - 1] == t[j - 1]) {
            // 删除,那么相同直接忽略
            dp[i][j] = dp[i - 1][j - 1];
            // s 是否是 t 子序列
            dp[i][j] = dp[i - 1][j - 1] + 1; // 表示的是相同的字符个数加一
            // s 子序列中 t 出现的次数
            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; // 表示的是 相同并且匹配 dp[i - 1][j - 1], 不匹配，那么使用前面的匹配 ： dp[i - 1][j],
        } else {
            // 删除，增删改：
            dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            // 调整的步数，如果两个都删除，那么总的次数 + 2 因为删两次
            dp[i][j] = min(dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            // s 子序列中 t 出现的次数,不同，所以删除 s 这一位的字符，因为不匹配
            dp[i][j] = dp[i - 1][j];
            // s 是否是 t 子序列, 不同，表示的不是的，所以 t 选 j - 1 个。
            dp[i][j] = dp[i][j - 1];
            
            // 规律：我们总是优先删除字符长的字符串
        }
    }
}
// 返回操作次数：
return dp[m][n];
// 返回的是：s 是否是 t 子序列
return dp[m][n] == s.size();
```



#### DP 滚动数组









#### DP 状态转移的考虑

* 我们每一次需要将所有的状态都考虑一遍，每一种状态下可以做哪些选择，

* 如： 挑选石子任务，每一次更新的时候，我们都需要考虑两个人的状态，两个人的选择在一次遍历都需要考略到

* 如：股票问题，我们在每一次的遍历过程中，需要考虑买入和卖出的两种情况

  ```c++
  // 买卖股票
  for (int i = 0; i < n; ++i) {  // 总共有 n 个股票价格
  	for (int k = 0; k < K; ++k) { // 总共最多可以执行 k 次交易
  		// base case {....}
  		dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); // 卖出
  		dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); // 买入
  		// 0 表示的是 当前不拥有股票， 1 表示的是当前拥有股票，当前的两种状态都需要更新
  		// 下面的 k - 1表示的是因为这个买入了一次，所以当前的交易次数，要比上一次交易多一次
  		// 只有在买入的时候 增加一次交易次数
  	}
  }
  ```

  

  

  ```c++
  // 石子游戏 I    
  // 两个人是交替选择的，当前选手的选择，一定会对之后选手的选择带来影响
  // 当前选手的选择就当成当前是先手，下一次就会变成后手，但是我们不管，当前永远选择的是最优的选择，
  // 但是当前的先手和后手都需要更新状态，否则之后没法往后传递转移方程
  for (int len = 0; len < n; ++len) {
  	for (int l = 0; l + len < n; ++l) {
  		int r = l + len;
  		if (len == 0) {....base case....}
  		int left = nums[l] + dp[l + 1][r][1]; // 当前选左边，相当于上一次我是后手
  		int right = nums[r] + dp[l][r - 1][1];
  		if (left > right) {
  			dp[l][r][0] = left;
  			dp[l][r][1] = dp[l + 1][r][0];  // 选石子交替进行的体现
  		} else {
  			dp[l][r][0] = second;
  			dp[l][r][1] = dp[l][r - 1][0];  // 因为每一次只选择一个所以只更新一个
  		}
  	}
  }
  ```



#### 股票问题

```c++
// 买卖股票
for (int i = 0; i < n; ++i) {  // 总共有 n 个股票价格
	for (int k = 0; k <= K; ++k) { // 总共最多可以执行 K 次交易
		// base case {....}
        // 注意边界问题： 当买卖两支股票的时候边界问题：如果当前交易次数为 0 但是却手握股票那么一定是不合法的
        if (i == 0 && k != 0) { // 若 j == 0 表示的是交易次数为0，但是却有股票，那么一定是不合法的
            dp[i][k][1] = -prices[0];
            continue;
        }
        if (k == 0) {
            dp[i][k][1] = -1e9;
            dp[i][k][0] = 0;
            continue;
        }
        
        // 注意边界，当买卖 K 支股票的时候边界条件和上面的边界条件是一样的
        
		dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); // 卖出,不拥有股票
		dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); // 买入，拥有股票
		// 0 表示的是 当前不拥有股票， 1 表示的是当前拥有股票，当前的两种状态都需要更新
		// 下面的 k - 1表示的是因为这个买入了一次，所以当前的交易次数，要比上一次交易多一次
		// 只有在买入的时候 增加一次交易次数
	}
}
```



#### 石子游戏

* 基本套路 ：

  > 当我们可以从**两端**取石子 ：**二维dp**
  >
  > 当我们**只**可从**一端**取石子 ：**一维dp**
  >
  > 当我们从石子堆里面**随机取**，**没规则 ** ：**贪心**

* dp 设置 ：

  > 二维dp ： `dp[l][r][k] k == 2`   表示的含义是：从 `[l,r]`  这个区间   `k`  （先手或后手） 可以取得的最大石子数量。 
  >
  > >  **最终的结果**：先手   `dp[0][r - 1][0]` 后手 ： `dp[0][r - 1][1]`。
  > >
  > >  **遍历顺序**：**范围**从小到大扩大。
  >
  > 一维dp ： `dp[l][k]`  表示的含义是：先手或者后手选择 `stones[l : end]`   能得到的最大石头数量。
  >
  > > **最终的结果**： 先手 ： `dp[0][0]`  后手： `dp[0][1] `   。
  >
  > >  **遍历顺序**：**从后向前进行**。
  >
  > 贪心 ：优先选择某一下标石子总数最多的，这样一方面自己获得的数量最多，一方面让对方没法选择这数量多的堆（注意：选完某一堆，对方也会剔除这个下标的石子堆）。

* dp 转移方程 :

  > 二维 dp ：
  >
  > > 基本原理 ： 选择左边或者右边 
  > >
  > > `dp[l][r][0] = max(stones[l] + dp[l + 1][r][1], stonrs[r] + dp[l][r - 1][1])`
  > >
  > > `dp[l][r][1]`  和先手有关，因为先手从左边转移过去的，那么： `dp[l][r][1] = dp[l + 1][r][0]` ,先手从右边转移过去的，那么 ： `dp[l][r][1] = dp[l][r - 1][0]` ,因为一次选择的过程中只能一人选择，所以后手从上一个先手转移过去的
  >
  > 一维 dp ：
  >
  > > 见题目。
  >
  > 贪心 ：
  >
  > > 见题目。

* 先手后手取石子的差值最大化 dp 设置

  > - 我们可以两端取石子 ：**二维dp**
  >
  >   > `dp[l][r]` :  表示的是从 `[l, r]` 这个区间 **先手和后手的差值**，这里没有先手后手那个维度，因为 `dp[l][r]` 存储的是当前范围先手后手的**差值**。**遍历顺序** ：**范围**从小到达。
  >
  >   >  转移方程基本原理 ：选择左边还是选择右边 ，选一个更大的。
  >
  >   > 二维 dp 的转移方程 ：`dp[l][r] = max(pre_sum[l + 1 : r] - dp[l + 1][r], pre_sum[l : r - 1] - dp[l][r - 1])`
  >
  > - 我们可以一端取石子 ： **一维dp**
  >
  >   > `dp[l]`  : 表示的是 **l 堆石子**先手和后手之间的差值。**遍历顺序**：**从后向前**进行， 当然使用找规律的方式范围也可以从小到达进行。
  >
  >   > 转移方程的基本原理 ：当前剩余 l 堆石子的总数，是由之前更多堆石子转移过来的
  >   >
  >   > 一维 dp 的转移方程 ： `dp[l] = max(dp[l + 1], pre_sum[l] - dp[l + 1])`



##### 石子游戏 I

###### 递归

```c++
int dp[501][501][2];
vector<int> solve(vector<int>& stones, int l, int r) {
    if (l == r) return vector<int>{stones[l], 0};
    if (dp[l][r][0] != 0) return vector<int>{dp[l][r][0], dp[l][r][1]};
    vector<int>left = solve(stones, l + 1, r);  // 这个表示的是 后手（相对于当前过程）获得的石子数量
    vector<int>right = solve(stones, l, r - 1);
    vector<int>max_res = {0, 0};
    if (left[1] + stones[l] > max_res[0]) {
        max_res[0] = left[1] + stones[l];
        max_res[1] = left[0];
    }
    if (right[1] + stones[r] > max_res[0]) {
        max_res[0] = right[1] + stones[r];
        max_res[1] = right[0];
    }
    dp[l][r][0] = max_res[0];
    dp[l][r][1] = max_res[1];
    return max_res;
}
```



###### 动态规划

```c++
int n = piles.size();
for (int len = 0; len < n; ++len) {
    for (int l = 0; l + len < n; ++l) {
        if (len == 0) {
            dp[l][l][0] = piles[l];
            dp[l][l][1] = 0;
            continue;
        }
        int r = l + len;
        if (dp[l + 1][r][1] + piles[l] > dp[l][r - 1][1] + piles[r]) {
            dp[l][r][0] = dp[l + 1][r][1] + piles[l];
            dp[l][r][1] = dp[l + 1][r][0];
        } else {
            dp[l][r][0] = dp[l][r - 1][1] + piles[r];
            dp[l][r][1] = dp[l][r - 1][0];
        }
    }
}
return dp[0][n - 1][0] > dp[0][n - 1][1];
```







#####  石子游戏 II

###### 递归

```c++
int dp[100 + 1][200 + 1][2];  // dp[i][j][k] 表示的是先手可以拿的最多的石子个数，i 表示的是从piles[i : end] 能拿的最多石子
    // j 表示的是 m = j 可以获得的最大石子数， k == 0 表示的是先手， k == 1 表示的是后手
vector<int> solve(vector<int>& piles, int st, int m) {  // st 表示的是起点的位置， m 表示的是题目中的范围
    if (st >= piles.size()) return vector<int>{0, 0};
    if (dp[st][m][0] != 0) return vector<int>{dp[st][m][0], dp[st][m][1]};  // 我们可以使用dp[st][m][0] 或者 dp[st][m][1]
    // 因为两者只要一个不是0，另外一个一定不是0
    vector<int>max_num = {0, 0};
    int sum = 0;
    for (int x = 1; x <= 2*m; ++x) {
        int idx = st + x - 1;  // 注意每一次从头开始不是从0， 是从 st 开始的
        if (idx >= piles.size()) break;
        sum += piles[idx];
        vector<int>res = solve(piles, st + x, max(x, m));  // 这个 m 也是变化的，所以我们需要将 m 作为参数传进去
        // 当前无论是先手还是后手，我们都将自己当做是先手
        if (res[1] + sum > max_num[0]) {
            max_num[0] = res[1] + sum;  // 当前的先手，是需要加上自己之前后手的石子数，加上当前自己作为先手获得的 sum 值
            max_num[1] = res[0];  // 当前的后手，并没有取石子，所以你只能继承之前的石子数量，就是之前作为先手的石子数量
        }
    }
    dp[st][m][0] = max_num[0];
    dp[st][m][1] = max_num[1];
    return max_num;
}
```



###### 动态规划

* 不会，哭了......





#####  石子游戏 III

###### 递归

```c++
vector<int> solve(const vector<int>& stoneValue, vector<vector<int>>& dp, int i) {
        // 上面这种方法是不行的，因为上面这种方法，是选择第一个，第二个或者是第三个，而不是可以连续取这几个
    if (i >= stoneValue.size()) return vector<int>{0, 0};
    if (dp[i][0] != INT_MIN) return dp[i];
    int sum = 0;
    vector<int>max_num = {INT_MIN, INT_MIN};
    for (int x = 1; x <= 3; ++x) {
        int idx = i + x - 1;
        if (idx >= stoneValue.size()) break;
        sum += stoneValue[idx];
        vector<int>res = solve(stoneValue, dp, i + x);  // res 记录的是之前的结果，相对于当前这一层递归而言
        if (res[1] + sum > max_num[0]) {
            max_num[0] = res[1] + sum;
            max_num[1] = res[0];
        }
    }
    dp[i] = max_num;
    return dp[i];
}
```



###### 动态规划

```c++
int size = stoneValue.size();
vector<vector<int>>dp(size + 3, vector<int>(2, 0));  // +3 的目的是防止后面的 dp 越界
// dp[i : end][j] 表示的是从 第 i 个位置一直往后选石子， j == 0 表示先手， j == 1 表示后手，
// 选得的最大石子数目是 dp[i][j]
for (int i = stoneValue.size() - 1; i >= 0; --i) {  // 为什么 i 是从后向前，因为我之后 dp 用到了后面的结果
    int sum = 0;
    vector<int>res(2, INT_MIN);
    for (int j = 1; j <= 3; ++j) {  // 我总共只有三种选择，我们遍历一下就可可以了
        int idx = j + i - 1;
        if (idx >= size) break;
        sum += stoneValue[idx];
        if (dp[idx + 1][1] + sum > res[0]) {
            res[0] = dp[idx + 1][1] + sum;
            res[1] = dp[idx + 1][0];
        }
    }
    dp[i][0] = res[0];
    dp[i][1] = res[1];
}
if (dp[0][0] > dp[0][1]) return "Alice";
if (dp[0][0] < dp[0][1]) return "Bob";
return "Tie";
```





##### 石子游戏 IV

###### 递归

```c++
bool solve(vector<int>&dp, int n) {
    if (n == 0) return false;
    if (dp[n] != -1) return dp[n];
    for (int i = 1; i * i <= n; ++i) {
        bool res = solve(dp, n - i*i);  // 这个是前一个结果
        if (res == 0) {
            dp[n] = 1;
            return true;  // 在这个区间中只要找到一个存在就可以了，因为我们都是希望找到最优的，所以只要能让对方为 false 就完成任务了

        }
    }
    dp[n] = 0;
    return 0;
}
```



###### 动态规划

```c++
vector<int>dp(n + 1, 0);
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j * j <= i; ++j) {
        if (dp[i - j * j] == 0) {
            dp[i] = 1;
            break;
        }
    }
}
return dp[n];
```



##### 石子游戏 V

###### 递归

```c++
int pre_sum[502];
int dp[501][501];
int solve(int l, int r) {
    if (l == r) return 0;
    if (dp[l][r] != 0) return dp[l][r];
    int res = 0;
    for (int k = l; k <= r; ++k) {
        int left = pre_sum[k + 1] - pre_sum[l];
        int right = pre_sum[r + 1] - pre_sum[k + 1];
        if (left > right) {
            res = max(res, right + solve(k + 1, r));
        } else if (left < right) {
            res = max(res, left + solve(l, k));
        } else {
            res = max(res, max(right + solve(k + 1, r), left + solve(l, k)));
        }
    }
    dp[l][r] = res;
    return dp[l][r];
}
```



###### 动态规划

```c++
// dp 求解，找到最优的分割点，动态规划求解
// 求一下前缀和，方便后面的求解
if (size == 1) return 0;
// vector<int>pre_sum(size + 1, 0);
int pre_sum[size + 1];
memset(pre_sum, 0, sizeof pre_sum);
// pre_sum[0] = stoneValue[0];
for (int i = 1; i <= size; ++i) {
    pre_sum[i] = pre_sum[i - 1] + stoneValue[i - 1];
}

// vector<vector<int>>dp(size + 1, vector<int>(size + 1, 0));
int dp[size][size];
memset(dp, 0, sizeof dp);
for (int len = 0; len < size; ++len) {
    for (int l = 0; l + len < size; ++l) {
        int r = l + len;
        if (len == 0) {
            continue;
        }
        // if (len == 1) {
        //     dp[l][r] = min(stoneValue[l], stoneValue[r]);
        //     continue;
        // }
        for (int k = 0; k < len; ++k) {
            int left = pre_sum[l + k + 1] - pre_sum[l];
            int right = pre_sum[r + 1] - pre_sum[l + k + 1];
            if (left > right) {
                dp[l][r] = max(dp[l][r], right + dp[l + k + 1][r]);
            } else if ( left < right) {
                dp[l][r] = max(dp[l][r], left + dp[l][l + k]);
            } else {
                dp[l][r] = max(dp[l][r], max(left + dp[l][l + k], right + dp[l + k + 1][r]));
            }
        }
    }
}
return dp[0][size - 1];
```



##### 石子游戏 VI

###### 贪心求解，因为是随机选择

```c++
struct Node {
    int val, idx;
    Node (int val, int idx) : val(val), idx(idx) {}
    bool operator < (const Node &a) const {
        return val < a.val;
    }
};
class Solution {
public:

    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
        // alice 和 bob 任意取，大概率贪心，从一段取 一维 dp 从两端取二维dp 从小区间到大区间，扩展
        int n = aliceValues.size();
        priority_queue<Node>pq;
        for (int i = 0; i < n; ++i) {
            pq.push(Node(aliceValues[i] + bobValues[i], i));  // 我们拿到某个值等于对方减伤相应他的石子数
            // 所以某个人的总收益是实际是两个人石子之和
        }
        int sum_a = 0, sum_b = 0;
        for (int i = 0; i < n; ++i) {
            if (i % 2 == 0) {
                int idx = pq.top().idx;
                sum_a += aliceValues[idx];
                pq.pop();
            } else {
                int idx = pq.top().idx;
                sum_b += bobValues[idx];
                pq.pop();
            }
        }
        if (sum_a > sum_b) return 1;
        return sum_a == sum_b ? 0 : -1;

    }
};
```



##### 石子游戏 VII

###### 递归

```c++
int dp[1010][1010];
int pre_sum[1010];
int solve(int l, int r) {
    if (l == r) return 0;
    if (dp[l][r] != 0) return dp[l][r];
    return dp[l][r] = max(pre_sum[r + 1] - pre_sum[l + 1] - solve(l + 1, r), pre_sum[r] - pre_sum[l] - solve(l, r - 1));
}
```



###### 动态规划

```c++
for (int i = 1; i <= n; ++i) {
    pre_sum[i] = pre_sum[i - 1] + stones[i - 1];
}
// return solve(0, n - 1);
// 解法二：dp
// 差值一定是大于 0 的，所以在仍一时刻 dp[i][j] 都是大于 0 的
// 两人的分差就是 Bob 每一次所拿的那个数字之和
// 所以整个博弈的过程是 Alice 希望 Bob 取的数字越大越好，
// Bob 希望自己取得的数字越小越好
// dp[i][j] 表示的是差值， 表示的是从 i ~ j 之间的最大差值，玩家的分的最大差值
// 这里的这个差值先手和后手都想最大化这个差值，先手好理解，
// 后手想最大化的原因是，让先手下一次取得的差值更小一点。

// 注意：这题是分差最大，并不是 最终的得分最大，因为有的时候 Bob 会选择一个大的数字，
// 让自己得到的总分较少，这样 Alice 之后得到的总分也比较少
for (int len = 0; len < n; ++len) {
    for (int l = 0; l + len < n; ++l) {
        if (len == 0){
            continue;
        }
        int r = l + len;
        dp[l][r] = max(pre_sum[r + 1] - pre_sum[l + 1] - dp[l + 1][r], pre_sum[r] - pre_sum[l] - dp[l][r - 1]);
    }
}
return dp[0][n - 1];
```



##### 石子游戏 VIII

* #### [1872. 石子游戏 VIII](https://leetcode.cn/problems/stone-game-viii/)

###### 递归

```c++
int pre_sum[N];
int dp[N];
int n;
int solve(int x) {
    if (x == n) return pre_sum[n];
    if (dp[x] != 0) return dp[x];
    // int res = pre_sum[n];
    // 下面这一部分如何优化到 O(1) 时间复杂度？？？
    // 注意通过仔细观察会发现 当前的结果只和其右边的值有关，是右边的值转移过来的
    // for (int i = x; i < n; ++i) {
    //     res = max(res, pre_sum[i] - solve(i + 1));
    // }
    dp[x] = max(solve(x + 1), pre_sum[x] - solve(x + 1));  // 当前选择的值，减去上一个人，上一个先手获得的分数差值

    return dp[x];
}
```



###### 动态规划

```c++
for (int i = 1; i <= n; ++i) {
    pre_sum[i] = pre_sum[i - 1] + stones[i - 1];
}
// 解法二： 动态规划
dp[n] = pre_sum[n];
for (int i = n - 1; i >= 2; --i) {
    dp[i] = max(dp[i + 1], pre_sum[i] - dp[i + 1]);  // 因为每一个人都足够聪明，所以当我们选择的数起不到积极反馈，不取
}
return dp[2];  // 表示这个到达最终的结果了，只有两堆石子了，无论如何都要取完
// dp[i] 表示的是只有 i 堆石子的时候，两个人取石子获得的差值，注意这个取完之后堆数要合并减少
// dp[1] = -1e9;// 因为题目的意思是至少需要取两堆石子，
for (int i = 2; i <= n; ++i) {
    if (i == 2) {
        dp[2] = pre_sum[n];
        continue;
    }
    dp[i] = max(pre_sum[n - i + 2] - dp[i - 1], dp[i - 1]);  // 这个转移方程是怎么得来的，一步一步推导出来的
    // 是找规律得到的
}
return dp[n];  // 这个思路和上面的思路正好相反，
// 反正都是石子的堆数，只不过，遍历的方向变了
```





#### 打家劫舍- 树形DP

##### 记忆化搜索

```c++
int solve(TreeNode* root, unordered_map<TreeNode*, int>& dp) {
    // 时间复杂度 ： O(n), 空间复杂度 ： O(n) + O(logn) (递归所用到的栈空间)
    if (root == nullptr) return 0;
    if (root -> left == nullptr && root -> right == nullptr) {
        return root -> val;
    }
    if (dp[root] != 0) return dp[root];  // 记忆化搜索
    // 选根节点：
    int val = root -> val;
    if (root -> left) {
        val += solve(root -> left -> left, dp) + solve(root -> left -> right,dp);
    }
    if (root -> right) {
        val += solve(root -> right -> left, dp) + solve(root -> right -> right, dp);
    }
    // 不选父亲节点
    int val_n = solve(root -> left, dp) + solve(root -> right, dp);
    dp[root] = max(val, val_n);
    return dp[root];
}
```

##### 树形 dp

```c++
vector<int> Solve(TreeNode* root) {
    // 时间复杂度 ： O(n) 空间复杂度 ： O(n) 
    if (root == nullptr) {
        return vector<int>{0, 0};
    }
    vector<int> left = Solve(root -> left);  // 回溯，使用了之前的结果
    vector<int> right = Solve(root -> right);
    // 选这个节点
    int val = root -> val + left[0] + right[0];
    // 步枪，下一家可强可不强，取决于收益的大小
    int val_n = max(left[0], left[1]) + max(right[0], right[1]);
    return vector<int>{val_n, val};
}
```



#### 扔鸡蛋

* 个人感觉有点类似  [石子游戏V](# 石子游戏 V)

###### 记忆化递归 （未优化）

```c++
int Solve(int k, int n, vector<vector<int>>& dp) {
    if (k == 1) return n;
    if (n == 0) return 0;
    if (dp[k][n] != 0) return dp[k][n];
    int res = INT_MAX;
    // // 二分法求解下面的问题
    // int l = 1, r = n;
    // while (l <= r) {
    //     int mid = (r - l) / 2 + l;
    //     int broken = Solve(k - 1, mid - 1, dp);
    //     int not_broken = Solve(k, n - mid, dp);
    //     if (broken > not_broken) {
    //         r = mid - 1;
    //         res = min(res, broken + 1);
    //     } else {
    //         l = mid + 1;
    //         res = min(res, not_broken + 1);
    //     }
    // }
    for (int i = 1; i <= n; ++i) {
        num = min(num, max(Solve(k - 1, i - 1, dp), Solve(k, n - i, dp)) + 1);
    }
    // cout << "ok" << endl;
    // cout << "num: " << num << endl;
    dp[k][n] = res;
    return dp[k][n];
}
```



###### 记忆化递归（二分法优化）

```c++
int Solve(int k, int n, vector<vector<int>>& dp) {
    if (k == 1) return n;
    if (n == 0) return 0;
    if (dp[k][n] != 0) return dp[k][n];
    int res = INT_MAX;
    // 二分法求解下面的问题，利用了单调递增，单调递减一定会有交点的特性，这个交点可以使用二分查找求得
    int l = 1, r = n;
    while (l <= r) {
        int mid = (r - l) / 2 + l;
        int broken = Solve(k - 1, mid - 1, dp);
        int not_broken = Solve(k, n - mid, dp);
        if (broken > not_broken) {
            r = mid - 1;
            res = min(res, broken + 1);
        } else if (broken < not_broken){
            l = mid + 1;
            res = min(res, not_broken + 1);
        } else {
            res = min(res, broken + 1);
            break;
        }
    }
    // for (int i = 1; i <= n; ++i) {
    //     num = min(num, max(Solve(k - 1, i - 1, dp), Solve(k, n - i, dp)) + 1);
    // }
    // cout << "ok" << endl;
    // cout << "num: " << num << endl;
    dp[k][n] = res;
    return dp[k][n];
}
```



###### 动态规划  (未优化)

```c++
vector<vector<int>>dp(N + 1, vector<int>(K + 1, 0));
for (int i = 0; i <= N; ++i) {
    dp[i][1] = i;
}
// 解法二： dp
// 时间复杂度 O(N^2*K)  空间复杂度 O(NK)
for (int i = 1; i <= N; ++i) {
    for (int j = 2; j <= K; ++j) { // 因为鸡蛋数为 1 的已近计算过了，不需要再次计算了
        // 因为之后的计算可能会对之前已经确定的值，进行修改这不是我们想要的，因为这个已经确定的是是不能修改的
        int res = INT_MAX;
        // 下面这一步可以使用二分查找的方式求解，因为 dp[k - 1][j - 1] 一定是单增的
        // dp[i - k][j] 一定是单减的，随着 k 的增加，所以我们的目的就是找到：
        // dp[k - 1][j - 1] 和 dp[i - k][j] 的交叉点就是我们希望求的目标值了
        for (int k = 1; k <= i; ++k) {
            res = min(res, max(dp[k - 1][j - 1] + 1, dp[i - k][j] + 1));
        }
        // int l = 1, r = i;
        // while (l <= r) {
        //     int mid = (r - l) / 2 + l;
        //     int broken = dp[mid - 1][j - 1];  // 碎了
        //     int not_broken = dp[i - mid][j]; // 没有碎
        //     // res = min(max(碎， 没碎)) + 1；
        //     if (broken > not_broken) {
        //         r = mid - 1;
        //         res = min(res, broken + 1);
        //     } else {
        //         l = mid + 1;
        //         res = min(res, not_broken + 1);
        //     }
        // }
        dp[i][j] = res;
    }
}
return dp[N][K];
```



###### 动态规划 （二分优化）

```c++
vector<vector<int>>dp(N + 1, vector<int>(K + 1, 0));
for (int i = 0; i <= N; ++i) {
    dp[i][1] = i;
}
// 解法二： dp
// 时间复杂度 ： O(NK*logN)  空间复杂度 ： O(NK)
for (int i = 1; i <= N; ++i) {
    for (int j = 2; j <= K; ++j) { // 因为鸡蛋数为 1 的已近计算过了，不需要再次计算了
        // 因为之后的计算可能会对之前已经确定的值，进行修改这不是我们想要的，因为这个已经确定的是是不能修改的
        int res = INT_MAX;
        // 下面这一步可以使用二分查找的方式求解，因为 dp[k - 1][j - 1] 一定是单增的
        // dp[i - k][j] 一定是单减的，随着 k 的增加，所以我们的目的就是找到：
        // dp[k - 1][j - 1] 和 dp[i - k][j] 的交叉点就是我们希望求的目标值了
        // for (int k = 1; k <= i; ++k) {
        //     res = min(res, max(dp[k - 1][j - 1] + 1, dp[i - k][j] + 1));
        // }
        int l = 1, r = i;
        while (l <= r) {
            int mid = (r - l) / 2 + l;
            int broken = dp[mid - 1][j - 1];  // 碎了
            int not_broken = dp[i - mid][j]; // 没有碎
            // res = min(max(碎， 没碎)) + 1；
            if (broken > not_broken) {
                r = mid - 1;
                res = min(res, broken + 1);
            } else {
                l = mid + 1;
                res = min(res, not_broken + 1);
            }
        }
        dp[i][j] = res;
    }
}
return dp[N][K];
```



###### 动态规划 （换思路了，没咋理解）

```c++
// 解法三：dp[i][j] = n 表示的是 i 个鸡蛋，最终最多扔 j 次, 这个状态下，最坏情况下最多确切测试 n 层楼
// j 表示的是扔鸡蛋的次数
// 时间复杂度 ： O(N)  空间复杂度 ： O(N*K)
vector<vector<int>> dp(K + 1, vector<int>(N + 1, 0));
int m = 0;
while (dp[K][m] < N) {
    m++;
    for (int i = 1; i <= K; ++i) {
        dp[i][m] = dp[i - 1][m - 1] + dp[i][m - 1] + 1;
        // 分成碎了，没碎，两个扔鸡蛋的次数都减少一次，不同的是一个鸡蛋损失了，一个鸡蛋没有损失
    }
}
return m;
```



#### LIS

##### 暴力：O(n^2)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int size = nums.size();
        vector<int>dp(size + 1, 1);
        // dp[0] = 1;
        int res = 1;
        for (int i = 1; i < size; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[j] + 1, dp[i]);
                }
            }
            res = max(res, dp[i]);
        }
        // for (auto c : dp) {
        //     cout << c << endl;
        // }
        return res;
    }
};
```



##### 二分优化 ： O(nlogn)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        // 二分查找
        // 思考一种  poker game ,也可以叫做 patience sorting
        int size = nums.size();
        vector<int>dp(size, 0);
        int tail = 0;
        for (int i = 0; i < size; ++i) {
            int num = nums[i];
            int l = 0, r = tail;
            while (l < r) {
                int mid = (r - l) / 2 + l;
                if (dp[mid] < num) l = mid + 1;
                else r = mid;
            }
            if (l == tail) ++tail;
            dp[l] = num;
        }
        return tail;
    }
};
```





##### LIS 进阶：二维 LIS

```c++
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        int size = envelopes.size();
        sort(envelopes.begin(), envelopes.end(),[] (const vector<int>& a, const vector<int>& b) {
            if (a[0] != b[0]) return a[0] < b[0];
            return a[1] > b[1];  // 注意，这里当长度相同的时候，宽度是按照递减的顺序排序，避免 [3, 3],[3, 4] 也进入符合条件的数组中
            //  如果 return a[1] < b[1], 那么 [[5,4], [6,4], [6,7], [2,3]] 输出结果是 2， 但是准确答案是 3
        });
        // vector<int>dp(size, 0);
        vector<vector<int>>dp(size, vector<int>(2, 0));
        int tail = 0;
        for (int i = 0; i < size; ++i) {
            int num1 = envelopes[i][0];
            int num2 = envelopes[i][1];
            int l = 0, r = tail;
            while (l < r) {
                int mid = (r - l) / 2 + l;
                if (num1 > dp[mid][0] && num2 > dp[mid][1]) {
                    l = mid + 1;
                } else {
                    r = mid;
                }
            }
            if (l == tail) ++tail;
            // dp[l][0] = envelopes[i][0];
            dp[l][0] = num1;
            dp[l][1] = num2;
        }
        return tail;
    }
};
```



#### 字符串总结

##### KMP

```c++
 // KMP算法时间复杂度为O(m+n)，空间复杂度为O(m)。 因为KMP算法涉及到next数组的存储，且next数组是基于模式串长度计算的。
// 前缀是指：第一个字符开始，不包含最后一个字符（一定要第一个字符开始）
// 后缀是指：最后一个字符结束，不包含第一个字符 （一定是最后一个字符结束）
// next[j] 表示的是在 j 位置最长想同步的前后缀长度是多少

void getNext(std::vector<int>& next, const std::string &s) {
    int j = 0;  // j 表示的是前缀终止的地方， i 表示的是后缀终止的地方
    next[0] = 0;
    for (int i = 1; i < s.size(); ++i) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j - 1]; // 这就是上面为什么是需要 j > 0 的原因
        }
        // 这个 while 有两种可能退出，一种是 j == 0 或者是 s[i] == s[j] 如果是这种，那么 j 就是大于0 的，此时表示的是之前已经有相同的前缀了
        // 这里还需要再加上 1
        if (s[i] == s[j]) ++j;  // 有可能 j == 0 这里还是不相同
        next[i] = j;  // 表示的是以 i 结尾（包含 i ）的最长相同前缀后缀的个数
    }
}

int main() {
    std::string txt, pat;
    cin >> txt >> pat;
    int m = pat.size();
    std::vector<int>next(m ,0);
    getNext(next, pat);
    // for (int i = 0; i < next.size(); ++i) {
    //     cout << next[i] << endl;
    // }
    int j = 0;
    int cnt  = 0;
    for (int i = 0; i < txt.size(); ++i) {
        while (j > 0 && txt[i] != pat[j]) {
            j = next[j - 1];
        }
        if (txt[i] == pat[j]) ++j;
        if (j == m) {
            cnt++;
            j = 0;
            // cout << i - m + 1 << endl;
            // return 0;
        }
    }
    cout << cnt << endl;
    return 0;
}
```



##### 字符串 hash



* hash 函数最重要的两个性质

>1. 在 hash 函数值不一样的时候，两个字符串一定不一样
>2. 在 hash 函数值一样的时候，两个字符串不一定一样（但是有大概率一样的，且我们当然希望它们总是一样的）  当 Hash 函数值一样的时候，原字符串却不一样的现象我们称为 hash 冲突

* hash 函数的设置

> $$
> f(s) =  {\textstyle \sum_{i = 1}^{l}s[i]\times b^{i-1}} (\bmod M)
> $$
>
> 例如： 对于字符串 xyz 其 hash 值是： 
> $$
> xb^2 + yb + z
> $$





```c++
// 写法一：hash 冲突处理

struct node {
    string key;
    int price;
};
const int N = 10005;

vector<node>List[N]; // 存放的是所有可能冲突的字符

unsigned int BKDRHash(const string& s) {
    unsigned int seed = 31, key = 0;  // 31 131 1313 13131 131313 etc..
    for (int i = 0; i < s.size(); i++) {
        key = key * seed + (s[i] - 'a');
    }
    return key & 0x7fffffff;
}

int main() {

    int num;
    int memory_price = 0;
    cin >> num;
    for (int i = 0; i < N; i++) {
        List[i].clear();
    }
    node s;
    for (int i = 0; i < num; i++) {
        cin >> s.key;
        auto key = BKDRHash(s.key) % N;  // 将较大的数值限定在比较小的范围内
        List[key].push_back(s);
    }
    int m;
    cin >> m;
    int p[N];
    while (m--) {
        int rank = 0;
        int len = 0;
        for (int i = 0; i < num; i++) {
            string str;
            int pri;
            cin >> pri >> str;
            auto key = BKDRHash(str) % N;
            for (int j = 0; j < List[key].size(); j++) {  // 下面这一部分就是解决冲突的部分
                if (str.compare(List[key][j].key) == 0) {
                    // 表示的是两个字符串相同
                    List[key][j].price += pri;
                    if (str.compare("memory") == 0) {
                        memory_price = List[key][j].price;
                    } else {
                        p[len++] = List[key][j].price;
                    }
                    break;
                }
            }

        }
        for (int i = 0; i < len; i++) {
            if (memory_price < p[i]) {
                rank++;
            }
        }
        cout << rank + 1 << endl;
    }


    return 0;
}
```



```c++
// 写法二：

// 字符串 hash 更常见的写法： 查找某个字符串中可以组成 a + a的字符串： LeetCode ：1316

typedef unsigned long long ULL;

// 注意如果溢出了就是需要取模处理
const int N = 2020;
ULL h[N];  // 存放的是下标为 i 的 hash 值
ULL p[N];  // 存放的是位置为 i 处的 次方值

/*
eg : str = "abcabc", P = 37
h[0] = 0
h[1] = 37 * a
h[2] = 37^2 * a + 37 * b
h[3] = 37^3 * a + 37^2 * b + 37 * c
h[4] = 37^4 * a + 37^3 * b + 37^2 * c + 37 * a
h[5] = 37^5 * a + 37^4 * b + 37^3 * c + 37^2 * a + 37 * b
h[6] = 37^6 * a + 37^5 * b + 37^4 * c + 37^3 * a + 37^2 * b + 37 * c

p[0] = 1, p[1] = 37, p[2] = 37^2, p[3] = 37^3, p[4] = 37^4, p[5] = 37^5, p[6] = 37^6

so Get(1, 1) = 37 * a,
Get(2, 2) = h[2] - h[1] * p[1] = 37^2 * a + 37 * b - 37 * a * 37 = 37 * b,
意思就是把前面的给删除了
*/



ULL Get(int l, int r) { // 包括 l 和 r 这个边界
    return h[r] - h[l - 1] * p[r - l + 1];
}


int solve(const string& s) {
    int P = 31;
    unordered_set<string> st;
    int n = s.size();
    p[0] = 1;
    h[0] = 0;
    for (int i = 1; i <= n; i++) {
        h[i] = P * h[i - 1] + (s[i - 1] - 'a');
        p[i] = p[i - 1] * P;
    }
    for (int len = 1; len < n; len++) {
        for (int l = 1; l + len + len - 1 <= n; l++) {
            int r = l + len - 1; // 因为可以比较两个单个字符，所以需要减一
            if (Get(l, r) == Get(r + 1, r + len)) {
                st.insert(s.substr(l, len));
            }
        }
    }
    return st.size();
}


```



```c++
// Amazon

/*
求原字符串和后缀字符串的公共前缀和，
eg : source : ababaa, suffix : ababaa,babaa, abaa, baa, aa, a,求source 和 suffix 的最长公共前缀和：
就是 6 + 0 + 3  + 0 + 1 + 1 = 11
*/

// 字符串 hash + 二分 时间复杂度 ： O(nlogn)

// 解法一 ： 使用字符串 hash + 二分将时间复杂度优化到 ： O(nlogn)
typedef unsigned long long ULL;
const int N = 1e5 + 10;
ULL h[N];
ULL p[N];
ULL get(int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}

bool solve(const string& s, int l, int r) {  // 当然这个里可以使用一个 unordered_map 存放 get 的结果
    if (get(1, r - l + 1) == get(l + 1, r + 1)) return true;
    return false;
}

// 解法二：后缀数组 : O(nlogn)


int main() {

    string s;
    cin >> s;
    h[0] = 0;
    p[0] = 1;
    ULL P = 31;
    for (int i = 1; i <= s.size(); i++) {
        h[i] = h[i - 1] * P + (s[i - 1] - 'a');
        p[i] = p[i - 1] * P;
    }

    // int l = 0, r = s.size();
    int res = 0;
    for (int i = 0; i < s.size(); i++) {
        int l = i, r = s.size() ;
        while (l < r) {
            int mid = (r - l) / 2 + l;
            if (solve(s, i, mid)) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        // cout << "l : " << l << " r : " << r << endl;
        int len = l == i ? 0 : l - i;
        // cout << "l : " << l << " r : " << r << "  i : " << i << " len : " << len << endl;
        res += len;
    }
}

```



```c++
// 写法三： 双向记录字符串 hash  + 二分
// Acwing 139 回文子串最大长度
typedef unsigned long long ULL;
const int N = 1000010;
ULL p[N];
ULL hl[N];
ULL hr[N];

ULL GetLeft(int l, int r) { // 均包含 l, r 这两个位置
    return hl[r] - hl[l - 1] * p[r - l + 1];
}
ULL GetRight(int l, int r) { // 从右向左逆序遍历： 包含 l, r 位置
    return hr[l] - hr[r + 1] * p[r - l + 1];
}
// bool IsPalindrome (int l, int r, int len) {

// }

bool isPalin(int l, int r) {
    return hl[r] - hl[l - 1] * p[r - l + 1] == hr[l] - hr[r + 1] * p[r - l + 1];
    // 思考一下为什么这样，因为左边 hl 是递减的 P^6 + P^5 + P^4 + P^3 + P^2 + P^1
    // 右边 hr 是递增的 P^1 + P^2 + P^3 + P^4 + P^5 + P^6
    // 所以如果[l, r]是回文串的话，那么左边和右边是对称的，所以从左到右的 字符串结果，和从右到左的回文串结果是一样的。
}

bool solve(const string& s, int len) {
    for (int i = 1; i + len - 1 <= s.size(); i++) {
        if (isPalin(i, i + len - 1)) {
            return true;
        }
    }
    return false;
}

// 这里使用字符串 hash 的时候需要注意一点的是， 奇数不行的时候，偶数有可能是可以的，所以需要单独考虑 奇数和偶数
// 要使用二分，必须保证答案具有单调性，就是说如果len满足条件，那么len-1也一定满足条件。但事实上这题并不具有这个特点，
// 不过我们可以进行一个变形：把奇数长度和偶数长度分开考虑。这是因为，如果有len(len >= 2)长度的回文串，那么把它“掐头去尾”后得到的这个len-2长度的串一定也是回文串。


int main() {
    string s;
    int num = 1;
    // acwing 139
    while (cin >> s && s != "END") {
        memset(p, 0, sizeof(p));
        memset(hl, 0, sizeof(hl));
        memset(hr, 0, sizeof(hr));
        p[0] = 1;
        int n = s.size();
        int P = 31;
        for (int i = 1, j = n; i <= n && j >= 1; i++, j--) {
            hl[i] = hl[i - 1] * P + (s[i - 1] - 'a');
            hr[j] = hr[j + 1] * P + (s[j - 1] - 'a');
            p[i] = p[i - 1] * P;
        }
        int l = 1, r = (n + 1) / 2;
        int res = 0;
        while (l <= r) { // 枚举最长的额长度
            int mid = (r - l) / 2 + l; // 这个 mid 就是我们要求的长度
            int odd = mid * 2 - 1;
            int even = mid * 2;
            if (solve(s, even)) { // 因为 even 一定是比 odd 大的，所以先判断偶数，再判断奇数
                res = even;
                l = mid + 1;
            } else if (solve(s, odd)) {
                res = odd;
                l = mid + 1;
            }else {
                r = mid - 1;
            }
        }
        cout << "Case " << num << ": " << res << endl;
        num++;
    }
}
```



##### Trie 树

```c++
// 解法二使用的是 Trie 树的解法
// 时间复杂度 ： 查找和插入单词的复杂度都是 O(m) ,其中 m 是插入和查询字符串的长度
// 空间复杂度 ： 有公共前缀的单词只需要存一次公共前缀节省了空间

// 法一：数据结构采用链表法，可能出现内存超了的情况

struct Trie {
    Trie* next[26];
    int num;
    Trie() { // 构造函数
        for (int i = 0; i < 26; i++) {
            next[i] = nullptr;
        }
        num = 0;
    }
};

Trie root; // 根节点不包含字符

void Insert(const string& s) {
    Trie* p = &root;  // 因为根节点不包含字符，所以每一次都是找下一个字符
    for (int i = 0; i < s.size(); i++) {
        if (p -> next[s[i] - 'a'] == nullptr) {
            p -> next[s[i] - 'a'] = new Trie();  // 现在是有了一块地址，不再是 nullptr 了
            // cout << p -> next[s[i] - 'a'] << endl;
            // 打印出 0x6110000000400 地址之类的东西
        }
        p = p -> next[s[i] - 'a'];
        p -> num++;
    }
}

int Find(const string& s) {
    Trie* p = &root;
    for (int i = 0; i < s.size(); i++) {
        if (p -> next[s[i] - 'a'] == nullptr) return 0;
        p = p -> next[s[i] - 'a'];
    }
    return p -> num;
}

// 法二：采用的是数组的方法，更常使用,不会出现内存爆炸的情况

int trie[1000010][26];  // 这个表示的是： 用数组定义字典树，存储下一个字符的 !!!位置!!! 注意是位置
int num[1000010];  // 这个表示的是：以某一字符串为前缀的单词数量
int pos = 1;  // 这个的含义是当前新分配的存储位置

void Insert_Array(const string& s) {
    int p = 0;  // 这个就是最初的根的位置，这也就是为什么 pos 设置成1, 因为根我们定义成 0
    for (int i = 0; i < s.size(); i++) {
        int n = s[i] - 'a';
        if (trie[p][n] == 0) {  // 表示的是这个字符 n 我们还没有分配空间
            trie[p][n] = pos++;  // 方便下一次内存的分配
        }
        p = trie[p][n];
        num[p]++;
    }
}

int Find_Array(const string& s) {
    int p = 0;
    for (int i = 0; i < s.size(); i++) {
        int n = s[i] - 'a';
        if (trie[p][n] == 0) return 0;  // trie[p][n] == 0 表示的是没有这个位置，因为我们分配的位置大小都是大于1 的
        p = trie[p][n];
    }
    return num[p];
}
```



##### Manacher

> 时间复杂度：`O(n)`
>
> 空间复杂度：`O(n)`
>
>  n : 字符串长度， 通常**回文串**的相关问题采用 manacher 算法复杂度小



```c++
/*
Manacher 算法 ： 时间复杂度： O(n)
原串操作，将每个字符之间插入一个 # 这样，我们就可以将原串
无论是偶数串和奇数串都变成奇数串，eg : aba -> #a#b#a#, abaabc -> #a#b#a#a#b#c#
定义一个数组： p[i] 存放的是以 i 为回文中心的最大回文半径， 所以最终的结果是 p[i] - 1
eg :
i:    1 2 3 4 5 6 7 8 9
str:  # a # b # a # b #
p[i]: 1 2 1 4 1 4 1 2 1

rt : 表示的是已近计算过的回文串能够到达的最远右边界的!!!下一个位置!!! 即： rt = max(j + p[j]), j 属于 [1, i - 1]
mid 表示的是 rt 所对应的最左侧的回文中心 有 ： mid + p[mid] == rt

现在需要做的是求数组 p[i]， 以及更新 mid 和 rt
求数组 p[i] : 分成两种可能 ：
i < rt :
可以由 i 关于 mid 对称点 j 来求 p[i], p[j] 可能被 p[mid] 所包围，也可能 p[j] 超过了 p[mid] 那么我们选择最小的 min(p[2 * mid - i], rt - i)
之后 p[i] 暴力向右扩张
i >= rt :
只有一种办法，只能暴力向右扩张，没有别的办法，因为没有可以借鉴的点，因为上面是在 p[mid] 的范围内 i 和 j 对应的元素一定相等

注意这里使用了一个小 trick 可以防止越界的情况，就是我们在元素第一个和最后一个字符加上一个不是 # 的字符

eg : !#a#b#a#b#@

*/

void Manacher(const string& str, vector<int>& p) {
    // 原串是 ： abab , str : !#a#b#a#b#@
    // 最终最长回文串是 max(p[i] - 1)
    // p[i] 表示的是回文半径，包括最后一个 # 所以需要减一
    int n = str.size();
    int rt = 0, mid = 0;
    for (int i = 1; i < n - 1; i++) { // 第一个字符和最后一个字符不考虑，因为是哨兵
        if (i < rt) {
            p[i] = min(p[2 * mid - i], rt - i); // 一定要取最小值，因为选择大的，表示 p[mid] 就错误了
            // 下面这个while 表示的是 rt 及更右侧的部分需要使用暴力进行扩展
            while (str[i + p[i]] == str[i - p[i]]) { // 因为加了哨兵，所以一定不会越界，因为最后一个或者第一个一定是和字符串中的是不同的
                // 以 i 为枢轴，四周扩散
                p[i]++;
            }
        } else {
            // 表示的是只能进行暴力扩展，因为没有信息可以进行辅助计算了
            p[i] = 1; // 因为下一次一定是从 + 1 或者 -1 开始的。
            while (str[i + p[i]] == str[i - p[i]]) {
                // 以 i 为枢轴，四周扩散
                p[i]++;
            }
        }
        // 接下来需要更新 rt 和 mid
        if (i + p[i] > rt) {
            rt = i + p[i]; // mid 表示的是 rt 所对应的最左侧的回文中心 有 ： mid + p[mid] == rt
            mid = i;
        }
    }
    res = max(res, p[i] - 1)
}
```





##### AC 自动机









##### 后缀数组









#### 树专题总结

##### 先序中序，中序后序构建树











##### 树状数组

* 使用范围：

  > * 数组不变求区间和： 前缀和、树状数组、线段树
  > * 多次修改某个数字，求区间和：树状数组、线段树
  > * 多次整体修改某个区间，求区间和：线段树、树状数组（看修改区间的数据范围）
  > * 多次将某个区间变成一个数字，求区间和：线段树、树状数组（看修改区间的数据范围）
  > * 树状数组还可以求逆序对的个数

* 经验：

  > * 线段树的代码很长，常数很大，实际表现一般，只有在不得不用的时候才考虑线段树。
  > * 优先级如下：
  > * 简单的求区间和，使用前缀和，差分有时也可解决
  > * 多次将某个区间变成一个数，使用线段树
  > * 其他情况：使用树状数组。

* 时间复杂度：一次操作： 单点修改：O(logn) ，区间查询： O(logn)

* 所以总的时间复杂度： O(nlogn)

* lowbit() 函数，如何求解数 n 最后一位 1 和后面所有 0 组成的数字结果是多少？

  > ```cpp
  > int n;
  > int res = n & (~n + 1); // 这个表示的是将 n 取反 然后 + 1 这样就可以得到最后一个 1 和后面的所有0， 所以结果就是 res .
  > // 我们知道在计算机中 反码 + 1 就是其负数， 所以最终可化简成：
  > int res = n & (-n)
  > ```

* ```cpp
	// 求前缀和过程：
	a[13]: 
	x = 13 : 1101
	x -= lowbit(x) : 13 - 1 = 12
	x -= lowbit(x) : 12 - 4 = 8
	x -= lowbit(x) : 8 - 8 = 0
	因为 a[0] = 0.
	pre_sum[13] = a[13] + a[12] + a[8]
	```

* ```cpp
	// 单点更新过程：这不是只需要更新一个就行了，需要更新一系列的值
	a[6] + 5;
	需要更新数组的哪些值呢？
	while (x <= n)
	x = 6;
	x += lowbit(x) : 6 + 2 = 8 -> a[8] += 5;
	x += lowbit(x) : 8 + 8 = 16 -> a[16] += 5;
	// 结束
	```

* ![image-20220404015737710](/Users/zhoubing/Library/Application Support/typora-user-images/image-20220404015737710.png)



```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
int n;
int t[N], nums[N];
// nums[i] 存放的就是输入的数组中的元素， t[i] 存的是以 i 为根的子树的和。
// 注意这里都是从下标是 1 开始的。 写代码的时候思考树的样子，思考向前还是向后
int lowbit(int x) {
    return x & (-x);
}

// 如果不是对数据进行增加，然后更新某一点的值，我们需要更新原始数组中的值,让其变成某一个数据
void update1(int i, int x) {  // 将 i 点的值变成 x
  	int num = nums[i];
  	nums[i] = x;
  	while (i <= n) {
      	t[i] = t[i] - num + val;
      	i += lowbit(i);
    }
}

void update(int i, int x) { // i 点的增量是 x
    while (i <= n) {
        t[i] += x;
        i += lowbit(i); // 需要向上更新，看能不能找到合适的需要更新的，更新是向后找，所以是 加
    }
}

int sum(int i) { // 求 nums[1 : i] 的区间和
    int res = 0;
    while (i > 0) { // 因为这里我们使用的是从下标是 1 开始的.
        res += t[i];
        i -= lowbit(i); // 注意这里我们采用的是向 前看 ，因为是求前缀和，所以需要向前找
    }
    return res;
}

int main() {
    n = 10;
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
      	int x = i;
        update(i, x);
    }
    cout << sum(3) << endl;
    return 0;
}
```









##### 线段树

* 单次操作 query 和 update 的时间复杂度都是 ： O(logn)
* 多次将某个区间变成一个数，使用线段树(否则使用 树状数组)

* 包含两个数组：原始数组 nums[] 以及将树拆分的数组，包含的是区间和的树中的数组
* ![image-20220404154053543](/Users/zhoubing/Library/Application Support/typora-user-images/image-20220404154053543.png)



```cpp
#include<bits/stdc++.h>

using namespace std;

void build_tree(vector<int>& nums, int idx, int l, int r, vector<int>& tree) {
    if (l == r) {  // 表示到最后一个叶子结点了
        tree[idx] = nums[l];
        return;
    }
    int mid = (r - l) / 2 + l;
    int left = idx * 2 + 1;
    int right = idx * 2 + 2;
    build_tree(nums, left, l, mid, tree);
    build_tree(nums, right, mid + 1, r, tree);
    tree[idx] = tree[left] + tree[right];
}

void update_tree(vector<int>& nums, int idx, int l, int r, vector<int>& tree, int update_idx, int update_val) {
    // 修改在 nums[idx] idx 下标的数组中的元素,所以需要在 tree 数组中更新和
    if (l == r) {
        nums[l] = update_val;
        tree[idx] = update_val;
        return;
    }
    int mid = (r - l) / 2 + l;
    int left = idx * 2 + 1;
    int right = idx * 2 + 2;
    if (update_idx >= l && update_idx <= mid) {
        update_tree(nums, left, l, mid, tree, update_idx, update_val);
    } else {
        update_tree(nums, right, mid + 1, r, tree, update_idx, update_val);
    }
    tree[idx] = tree[left] + tree[right];
}

int query_tree(vector<int>& nums, int idx, int l, int r, vector<int>& tree, int L, int R) {
    // [L, R] 使我们需要求的那个求和数组的范围
    if (r < L || R < l) return 0; // 不在我们需要查找的范围内，所以可以直接的跳过
    if (l >= L && r <= R) return tree[idx];
    int mid = (r - l) / 2 + l;
    int left = idx * 2 + 1;
    int right = idx * 2 + 2;
    int left_sum = query_tree(nums, left, l, mid, tree, L, R);
    int right_sum = query_tree(nums, right, mid + 1, r, tree, L, R);
    return left_sum + right_sum;
}

int main() {
    // nums 表示的是原始数据的大小， tree 表示的是范围和，根是 [0 : n] 的和， 左边是 [0 : n / 2] 的和，右边是： [n / 2 + 1 : n] 的数组和
    vector<int> nums{1, 3, 5, 7, 9, 11};
    vector<int> tree(1000);
    int n = nums.size();
    build_tree(nums, 0, 0, n - 1, tree);  // 分别表示的是 idx = 0 开始，然后 nums 数组的范围
    // for (int i = 0; i < 15; i++) {
    //     cout << tree[i] << endl;
    // }
    update_tree(nums, 0, 0, n - 1, tree, 4, 6);
    for (int i = 0; i < 15; i++) {
        cout << tree[i] << endl;
    }
    cout << "--------------------" << endl;
    cout << query_tree(nums, 0, 0, n - 1, tree, 2, 4) << endl;
    return 0;
}

```











##### Treap 树







##### Splay 树





##### 二叉搜索树模板--增删改查

```c++
// 注意充分利用二叉搜素树中序遍历有序的特征
TreeNode *pre = nullptr;
int solve(TreeNode* root) { 
    // 通常在判断某一颗树的特性的时候，我们只需要找到反例就可以了，因为返回的是 && 所以只需要找到反例
    if (root == nullptr) return 0;
    bool left = solve(root -> left);
    if (pre != nullptr && pre -> val > root -> val) return false;  // 通常需要在这里进行相应的判断，操作等
    pre = root; // 记录前一个节点,无论如何都需要记录前一个节点
    bool right = solve(root -> right);
    return left && right;
}

// 二叉搜索树可以使用左右遍历查找某些东西
// 寻找二叉搜索树的最近公共父节点

// 非递归解法
TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* p) {
    if (p -> val > q -> val) swap(p, q);
    while (root) {
        if (root -> val > p -> val && root -> val > q -> val) {
            root = root -> left;
        } else if (root -> val < p -> val && root -> val < q -> val) {
            root = root -> right;
        } else {
            return root;
        }
    }
    return nullptr;
}

// 递归解法：
TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* q){
    //if(root == nullptr) return root;
    if (root->val >= p->val && root->val <= q->val) return root;
    if (root->val > p->val && root->val > q->val) return solve(root->left, p, q);
    if (root->val < p->val && root->val < q->val) return solve(root->right, p, q);
    return nullptr;
    //return ;
}

// 万能解法：求最近公共节点
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    //后序遍历回溯求解这个问题，这个之前的判断是为了之后我们返回用的。最终返回的是一个节点
    if (root == nullptr || root == p || root == q) return root;
    TreeNode* left = lowestCommonAncestor (root -> left, p, q);
    TreeNode* right = lowestCommonAncestor (root -> right, p, q);
    if (left && right) return root;
    if (left == nullptr && right == nullptr) return nullptr;
    else if (left == nullptr && right != nullptr) return right;
    else return left;
}

// 查
TreeNode* solve(TreeNode* root, int val) {
    if (root == nullptr) return ...;
    if (root -> val == val) return root;
    if (root -> val < val) { // 注意只需要遍历一边就可以了。每次都减少一般
        return solve(root -> right, val);  // 注意找到满足条件的就不会再往下遍历了，直接返回
        // 不会像 后序遍历 那样一直需要遍历到最底部，然后一步一步向上回溯
    } else {
        return solve(root -> left, val);
    }
}

// 增
// 注意增一定是发生在叶子节点的位置

TreeNode* solve(TreeNode* root, int val) {
    if (root == nullptr) {
        // 表示的是我们找到符合条件的位置，那么我们开始插入吧
        return new TreeNode(val);
    }
    if (root -> val > val) {
        root -> left = solve(root -> left, val);
    } else {
        root -> right = solve(root -> right, val);
    }
    return root;
}

// 删除
// 删除 更加的复杂
TreeNode* solve(TreeNode* root) {
    if (root == nullptr) return nullptr;
    if (root -> val == key) {
        // 如果左右均是空，那么直接返回空
        if (root -> left == nullptr && root -> right == nullptr) return nullptr;
        // 第二种情况 ： 左边为空，那么返回右边
        if (root -> left == nullptr) return root -> right;
        // 第三种情况： 右边为空，返回左边
        else if (root -> right == nullptr) return root -> left;
        else {
            // 第四种情况， 左右均不是空，那么将根节点的左孩子放到根节点的右孩子最左边，然后返回的是右孩子
            TreeNode* ret = root -> right;
            // TreeNode* pre = nullptr;
            while (ret -> left) {
                ret = ret -> left;
            }
            ret -> left = root -> left;
            return root -> right;
        }
    }
    if (root -> val > key) root -> left = deleteNode(root -> left, key);
    if (root -> val < key) root -> right = deleteNode(root -> right, key);
    return root;
}
```











##### 求树的高度和深度

* **高度** 是从下到上，所以适合使用后序遍历，回溯求解。
* **深度** 是从上到下，所以适合使用先序遍历。

```c++
// 高度
/*
4
3
2
1
*/
int max_Height = 0;
void getHeight (TreeNode* root, int depth) {
    if (root == nullptr) return ;
    if (root -> left) getHeight(root -> left, depth + 1);
    if (root -> right) getHeight(root -> right, depth + 1);
    max_height = max(max_Height, depth);  // 当然你可以在这里执行很多个操作
}


// 深度
/*
1
2
3
4
*/

int max_depth = 0;
void getDepth(TreeNode* root, int depth) {
    if (root == nullptr) return;
    max_depth = max(max_depth, depth);  // 当然你也可以在这执行很多的操作
    if (root -> left) getDepth(root -> left, depth + 1);
    if (root -> right) getDepth(root -> right, depth + 1);
}
```



#### 恢复二叉树的三种方法

* 先序 + 中序











* 后序 + 中序











* 层序 + 中序

















#### 图论专题总结

##### 布尔运算（递归 / 区间DP)

```cpp
class Solution {
public:
    vector<int> solve(string s, int left, int right, vector<vector<vector<int>>>& dp) {
        vector<int>res(2);
        if (left >= right) {
            res[s[left] - '0'] = 1;
            return res;
        }
        if (dp[left][right][0] != -1 && dp[left][right][1] != -1) {
            return dp[left][right];
        }
        for (int i = left; i <= right; i++) {
            if (s[i] == '0' || s[i] == '1') continue;
            vector<int> left1 = solve(s, left, i - 1, dp);
            vector<int> right1 = solve(s, i + 1, right, dp);
            if (s[i] == '&') {
                res[0] += left1[0] * right1[0] + left1[1] * right1[0] + left1[0] * right1[1];
                res[1] += left1[1] * right1[1]; 

            } else if (s[i] == '^') {
                res[0] += left1[0] * right1[0] + left1[1] * right1[1];
                res[1] += left1[1] * right1[0] + left1[0] * right1[1];
            } else if (s[i] == '|') {
                res[1] += left1[1] * right1[1] + left1[1] * right1[0] + left1[0] * right1[1];
                res[0] += left1[0] * right1[0]; 
            }
        }
        dp[left][right][0] = res[0];
        dp[left][right][1] = res[1];
        return res;
    }
    int countEval(string s, int result) {
        // 先求出合法的括号，然后计算的到最终的数值
        // 解法一： 区间 DP
        // 解法二： 241 类似使用递归求解，递归一定要熟知层这个概念 
        int n = s.size();
        if (n == 0) return 0;
        if (n == 1) {
            if (s[0] == '1') return result == 1 ? 1 : 0;
            else return result == 0 ? 1 : 0;
        }
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));
        // dp[i][j][0] 表示的是 i-j 位置为 0 的可能个数
        // dp[i][j][1] 表示的是 i-j 位置为 1 的可能个数
        // 这个一定是从小区间到大区间的
        for (int i = 0; i < n; i += 2) {
            dp[i][i][s[i] - '0'] = 1;
        }
        
        for (int len = 2; len < n; len += 2) {
            for (int l = 0; l + len < n; l += 2) {
                int r = l + len;
                for (int k = l + 1; k <= r - 1; k += 2) {
                    if (s[k] == '&') {
                        dp[l][r][1] += dp[l][k - 1][1] * dp[k + 1][r][1];
                        dp[l][r][0] += dp[l][k - 1][0] * dp[k + 1][r][0] + dp[l][k - 1][0] * dp[k + 1][r][1] + dp[l][k - 1][1] * dp[k + 1][r][0];
                    } else if (s[k] == '^') {
                        dp[l][r][0] += dp[l][k - 1][0] * dp[k + 1][r][0] + dp[l][k - 1][1] * dp[k + 1][r][1];
                        dp[l][r][1] += dp[l][k - 1][1] * dp[k + 1][r][0] + dp[l][k - 1][0] * dp[k + 1][r][1];
                    } else if (s[k] == '|') {
                        dp[l][r][0] += dp[l][k - 1][0] * dp[k + 1][r][0];
                        dp[l][r][1] += dp[l][k - 1][1] * dp[k + 1][r][1] + dp[l][k - 1][0] * dp[k + 1][r][1] + dp[l][k - 1][1] * dp[k + 1][r][0];
                    }
                }
            }
        }
        return dp[0][n - 1][result];
    }
};
```







##### 环路检测(DFS)

```cpp
#include<bits/stdc++.h>

using namespace std;
const int N = 1e4;
vector<int>g[N];

int color[N];
int last;
// color[i] = 0 表示正在判环的过程， color[i] = -1 表示还没有进行判环 color[i] = 1 表示的是已经执行完判环操作，
// 并且和这个结点形成的连通图是不存在环的

// 有向图判断是否存在环：
bool dfs(int i) {
    color[i] = 0; // 表示的是正在判环的过程中
    for (auto& v : g[i]) {
        if (color[v] == 0) {
            // 表示的是需要判环的结点已经在环中了，那么存在环
            return false;
        } else if (color[v] == -1) {
            if (!dfs(v)) return false; // 这里直接返回的，不会说接着执行 for 循环，不会的，因为递归回到这一步也是 return false
        }
    }
    color[i] = 1;  // 表示的是 i 结点形成的连通子图是不存在环的
    return true;
}

// 无向图判断是否存在环, 注意需要一个 last 记录上一次的结点,避免再一次遍历
bool dfs1(int i, int last) {
    color[i] = 0;
    for (auto& v : g[i]) {
        if (color[v] == 0 && last != v) {
            return false;
        } else if (color[v] == -1) {
            last = i;
            bool flag = dfs(v, last);
            if (flag == false) return flag; // 如果flag == true 可能存在后面节点还没有遍历到的情况，所以不能返回 true
        }
    }
    color[i] = 1;
    return true;
}

int main() {
    // 判断一个图是否存在环，这个图可能不连通，所以考虑需要仔细一点
    // 既可判断有向图也可以考虑无向图
    int n;
    cin >> n;

    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    // 可能存在不连通的情况，所以每一个结点都需要遍历一遍
    memset(color, -1, sizeof(color));
    for (int i = 0; i < N; i++) {
        if (g[i].size() == 0) continue;
        if (color[i] == -1) {
            if (!dfs1(i, -1)) {
                cout << "有环" << endl;
                return 0;
            }
        }
    }
    cout << "无环" << endl;
    return 0;
}
```



##### [最短路径](#最短路径总结)

##### 拓扑排序

* BFS & DFS 均可， 但是 DFS 不能输出字典序最小的结果，因为：**DFS 是深度搜索，处理的是上下级的关系，不能处理同级次的关系**

```c++
// 输出的是字典序，只有一种结果
// hdu 1285
// 需要输出的是字典序，所以必须使用的是 BFS ，DFS 不能出处理同一层次之间的关系，只能处理上下级之间的关系
// 只输出一种拓扑排序的结果
int m, n;
const int N = 1e5 + 10;
vector<int>edge[N];
vector<int>indeg(N);

bool topo_sort(vector<int>& res) {
    priority_queue<int, vector<int>, greater<int> >pq; // 小顶堆，优先是输出小的数据
    // 优先队列默认使用的是大顶堆，优先输出大的数据
    for (int i = 1; i <= m; i++) {
        if (indeg[i] == 0) {
            pq.push(i);
        }
    }

    while (!pq.empty()) {
        int top = pq.top();
        pq.pop();
        res.push_back(top);
        for (int i = 0; i < edge[top].size(); i++) {
            indeg[edge[top][i]]--;
            if (indeg[edge[top][i]] == 0) {
                pq.push(edge[top][i]);
            }
        }
    }

    for (int i = 1; i <= m; i++) {
        if (indeg[i] != 0) return false;
    }

    return true;
}

int main() {

    cin >> m >> n;

    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        edge[a].push_back(b);
        indeg[b]++;
    }

    vector<int>res;
    bool flag = topo_sort(res);

    if (!flag) cout << "There is a circle" << endl;
    else {
        for (int i = 0; i < res.size(); i++) {
            cout << res[i] << " ";
        }
        cout << endl;
    }
    return 0;
}
```











##### 最小生成树 - Kruskal

* kruskal 时间复杂度主要分成两个部分 ： 对边的排序 ： `O(ElogE)` , 并查集的操作 ： `O(E)`  总的时间复杂度 ：`O(ElogE + E)` 约等于 ： `O(ElogE)`

```c++
const int N = 1e5 + 10;
int f[N];

void Init() {
    for (int i = 0; i< N; i++) {
        f[i] = i;
        s[i] = 1; // 表示当前连通块中节点的数量
    }
}

int Find(int x) {
    if (f[x] != x) return f[x] = Find(f[x]);
    return f[x];
}

void Union(int x, int y) {
    int fx = Find(x);
    int fy = Find(y);
    f[fx] = fy;
}

void Ubion1(int x, int y) {
    // 需要加上当前连通块节点的数量和
    int fx = Find(x);
    int fy = Find(y);
    if (fx != fy) {
        // 注意相同不需要执行下面的操作
        f[fx] = fy;
        s[fy] += s[fx]; // 从而获取整个连通块中节点的数量和，注意现在父亲是 fy 所以需要将数量 + 到父亲上，获取总的节点数量
    }
}

struct Node {
    int from, to, w;
    Node(int a, int b, int c) : from(a), to(b), w(c) {}
};
vector<Node>edge;
```









##### 二分图

* BFS 染色法， 就是相邻的两个节点的颜色一定不同，相同则不是二分图
* 时间复杂度： O(M+N) 空间复杂度 ：O(N)  N ： 节点数， M：边数

```c++
// leetcode 886
// 解法二： BFS 染色法， 两个相邻的节点一定染成不同的颜色，如果不行，那么 return false
bool solve(int N, vector<vector<int>>& dislikes) {
    unordered_map<int, vector<int>>mp;
    for (auto c : dislikes) {
        mp[c[0]].push_back(c[1]);
        mp[c[1]].push_back(c[0]);
    }
    vector<int>color(N + 1, 0);
    queue<int>que;
    for (int i = 1; i <= N; i++) {  // 有可能这个图有多个连通子图。就是这个二分图连通块大于1
        if (color[i] != 0) continue;
        color[i] = 1; // 初始赋值成 1，我们相邻的染成不同的颜色，可以染成颜色 2
        que.push(i);
        while (!que.empty()) {
            int size = que.size();
            for (int j = 0; j < size; j++) {
                int front = que.front();
                que.pop();
                int col = color[front];
                int nxt_col = col == 1 ? 2 : 1;
                // int nxt_col = -col;
                for (auto c : mp[front]) {
                    if (color[c] == col) return false;
                    else if (color[c] == 0) {
                        color[c] = nxt_col;
                        que.push(c);
                    }
                }
            }
        }
    }
    return  true;
}
```



* 并查集
* 时间复杂度 ： O(M+N)， 空间复杂度 ：O(N)   N ： 节点数， M ： 边数



```c++
void init() {
    for (int i = 0; i < N; i++) {
        f[i] = i;
    }
}
int Find(int x) {
    if (f[x] != x) return f[x] = Find(f[x]);
    return f[x];
}
void Union(int x, int y) {
    int fa = Find(x);
    int fb = Find(y);
    f[fb] = fa;
}
bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
    // leetcode 886
    // 一开始就想到使用并查集求解
    // 将自己的小伙伴加入到自己对立的那个组中，如果新来的一个组都放到同一个数组中，那么不合规 return false
    // 解法一： 并查集
    int n = dislikes.size();
    if (n <= 1) return 1;
    init();
    unordered_map<int, vector<int>> mp;
    for (auto c : dislikes) {
        mp[c[0]].push_back(c[1]);
        mp[c[1]].push_back(c[0]);
    }
    for (int i = 1; i <= N; i++) {
        auto vec = mp[i];
        for (auto v : vec) {
            if (Find(i) == Find(v)) {
                return false;
            }
            // vec 内部的才是兄弟，才是属于一个集合中的
            Union(vec[0], v);
        }
    }
    return true;
}
```



* DFS 
* 时间复杂度 ： O(M+N)， 空间复杂度 ：O(N + M)   N ： 节点数， M ： 边数



```c++
bool solve(int i, int c, unordered_map<int, vector<int>>& mp, vector<int>& color) {
    if (color[i] != 0) return c == color[i];  // 思考一下，因为我们当前的 c 就是需要赋值的颜色值
    color[i] = c;
    for (auto v : mp[i]) {
        if (!solve(v, -c, mp, color)) {  // 如果出现不符合条件的直接返回 false, 如果是 true 接着找，因为按理说应该大量的 true。
            // 这里 return false 有点类似回溯，之后一步一步往上一直 return false 不再 for 里面接着遍历了，直接返回了
            // 存在一个不符合条件的就返回，而我们的目的也是找到那个不符合条件的就 OK 了
            return false;
        }
    }
    return true;
}

bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
    unordered_map<int, vector<int>>mp;
    for (auto c : dislikes) {
        mp[c[0]].push_back(c[1]);
        mp[c[1]].push_back(c[0]);
    }
    vector<int>color(N + 1, 0);
    for (int i = 1; i <= N; i++) {
        if (color[i] != 0) continue;
        if (solve(i, 1, mp, color) == false) return false;
    }
    return true;
}
```





#### 分治法 / 排序

* 排序算法，左右边界都是包括在内的 [ , ],而不是 ( , ) 这种

* 稳定算法 : [冒泡排序](https://baike.baidu.com/item/冒泡排序)、[直接插入排序](https://baike.baidu.com/item/直接插入排序)、[折半插入排序](https://baike.baidu.com/item/折半插入排序)、[归并排序](https://baike.baidu.com/item/归并排序)
* 不稳定算法 ： [堆排序](https://baike.baidu.com/item/堆排序)、[快速排序](https://baike.baidu.com/item/快速排序)、[希尔排序](https://baike.baidu.com/item/希尔排序)、[直接选择排序](https://baike.baidu.com/item/直接选择排序)

##### 快速排序

* 时间复杂度 ： O(nlogn)，最坏时间复杂度 ： O(n^2)(退化成冒泡排序），空间复杂度 ：O(1)

```c++
// 传统快排：时间复杂度 ： O(nlogn)，最坏时间复杂度 ： O(n^2)
void QuickSort(vector<int>& a, int begin, int end) {
    if (begin < end) {
        int l = begin, r = end;
        int val = a[l];
        while (l < r) {
            while (l < r && val < a[r]) r--;
            if (l < r) {
                a[l] = a[r];
                l++;
            }
            while (l < r && val > a[l]) l++;
            if (l < r) {
                a[r] = a[l];
                r--;
            }
        }
        a[l] = val;
        QuickSort(a, begin, l - 1);
        QuickSort(a, l + 1, end);
    }
}
```

* 按照指定的 cmp 函数排序

```c++
bool lcmp(int x, int y) {
    return x < y;
}

bool rcmp(int x, int y) {
    return x > y;
}

void QuickSort(vector<int>& nums, int left, int right, bool(f*)(int, int)) { // 这种是比较好理解的写法
    if (left < right) {
        int l = left;
        int r = right;
        int num = nums[l];
        while (l < r) {
            while (l < r && cmp(num, nums[r]))r -= 2;
            if (l < r) {
                nums[l] = nums[r];
                l += 2;
            }
            while (l < r && cmp(nums[l], num))l += 2;
            if (l < r) {
                nums[r] = nums[l];
                r -= 2;
            }
        }
        nums[l] = num;
        QuickSort(nums, left, l - 2, cmp);
        QuickSort(nums, l + 2, right, cmp);
    }
}
vector<int> sortEvenOdd(vector<int>& nums) {
    if (nums.size() <= 2) return nums;
    // 解法二： 快排，原地排序，触及到快排的底层了
    /*
    function<bool(int, int)>lcmp = [&](int a, int b) {
        return a < b;
    };
    function<bool(int, int)>rcmp = [&](int a, int b) {
        return a > b;
    };
    */
    int n = nums.size();
    // cout << n << endl;
    if (n % 2 == 0) {
        QuickSort(nums, 0, n - 2, &lcmp);  // 边界自己举个例子就行了
        QuickSort(nums, 1, n - 1, &rcmp);
    } else {
        QuickSort(nums, 0, n - 1, &lcmp);
        QuickSort(nums, 1, n - 2, &rcmp);
    }
    return nums;
}
```

```c++
// 利用快速排序的特性求 Top K 以及 元素超过一般元素的元素
int Partition(vector<int>&nums, int left, int right) {
    if (left < right) {
        int l = left;
        int r = right;
        // int mid = (r - l) / 2 + l;
        int num = nums[l];
        while (l < r) {
            while (l < r && num <= nums[r]) r--;
            if (l < r) {
                nums[l] = nums[r];
                l++;
            }
            while (l < r && num >= nums[l]) l++;
            if (l < r) {
                nums[r] = nums[l];
                r--;
            }
        }
        nums[l] = num;
        return l;
    }
    return left;
}
void QuickSort(vector<int>&nums, int left, int right, int index) {
    // if (left < right) {
    if (left >= right) return;
    int idx = Partition(nums, left, right);
    if (idx == index - 1) { // 注意这个 idx == index - 1 因为是需要求 top k（没有 top 0 当然具体问题具体分析）
      	return ;
    } else if (idx > index) {
      	return QuickSort(nums, left, idx - 1, index);
    } else {
      	return QuickSort(nums, idx + 1, right, index);
    }
}
```

```cpp
// 随机快排，就是每一次取随机的枢轴
int Partition(vector<int>& nums, int left, int right) {
    if (left < right) {
        int l = left;
        int r = right;
        int val = nums[l];
        while (l < r) {
            while (l < r && nums[r] > val) r--;
            if (l < r) {
                nums[l] = nums[r];
                l++;
            }
            while (l < r && nums[l] < val) l++;
            if (l < r) {
                nums[r] = nums[l];
                r--;
            }
        }
        nums[l] = val;
        return l;
    }
    return left;
}

void QuickSort(vector<int> &nums, int left, int right) {
    if (left < right) {
        srand((unsigned)time(NULL));
        int rand_idx = rand() % (right - left + 1) + left;
        swap(nums[left], nums[rand_idx]);
        int idx = Partition(nums, left, right);
        QuickSort(nums, left, idx - 1);
        QuickSort(nums, idx + 1, right);
    }
}
```





```cpp
// 快排非递归，就是使用栈模拟快排的分割的部分：
int Partition(vector<int>& nums, int left, int right) {
    if (left < right) {
        int l = left;
        int r = right;
        int val = nums[l];
        while (l < r) {
            while (l < r && nums[r] > val) r--;
            if (l < r) {
                nums[l] = nums[r];
                l++;
            }
            while (l < r && nums[l] < val) l++;
            if (l < r) {
                nums[r] = nums[l];
                r--;
            }
        }
        nums[l] = val;
        return l;
    }
    return left;
}

void QuickSort(vector<int>& nums, int left, int right) {
    if (left < right) {
        stack<PII>st;
        st.push(PII(left, right));
        while (!st.empty()) {
            auto top = st.top();
            st.pop();
            int l = top.first;
            int r = top.second;
            int idx = Partition(nums, l, r);
            if (l < idx - 1) {
                st.push(PII(l, idx - 1));
            }
            if (idx + 1 < r) {
                st.push(PII(idx + 1, r));
            }
        }
    }
}
```

* 链表快排

```cpp
// 链表快速排序
struct ListNode{
    int val;
    ListNode* next;
    ListNode(int val) : val(val), next(nullptr) {}
    ListNode(int val, ListNode* next) : val(val), next(next) {}
};

// 使用两个指针， next 就是一直向下找的指针 ,partition 就是找到我需要下一次分割的位置

void swap(ListNode* node1, ListNode* node2) {
    auto temp = node1 -> val;
    node1 -> val = node2 -> val;
    node2 -> val = temp;
}

ListNode* Partition(ListNode* begin, ListNode* end) {
    ListNode* p = begin;
    ListNode* last = begin -> next;
    int val = begin -> val;
    while (last != end) {
        if (last -> val < val) {
            p = p -> next;
            swap(p, last);  // 注意先后顺序不能出错
        }
        last = last -> next;
    }
    swap(begin, p);
    return p;
}

void QuickSort(ListNode* begin, ListNode* end) {  // 注意这个是左闭右开，因为最右边的元素一定是不考虑的
    if (begin != end) {
        ListNode* partition = Partition(begin, end);
        QuickSort(begin, partition);
        if (partition != end) {
            QuickSort(partition -> next, end);
        }
    }
}
```





##### 归并排序

* 平均和最差和最好的时间复杂度均是 ： O(nlogn)，空间复杂度 ：O(n)



```c++
// 递归解法 分成分解与合并
// 合并部分

void Merge(vector<int>& num, int l, int r, int mid) {
    int len = r - l + 1;
    vector<int>temp(len);  // 这个就是归并排序需要的额外的 ： O(n) 空间来源
    int i = 0;
    int left = l;
    int right = mid + 1;
    while (left <= mid && right <= r) {
        if (num[left] <= num[right]) {
            temp[i] = num[left];
            left++;
            i++;
        } else {
            temp[i] = num[right];
            right++;
            i++;
        }
    }
    // left 或者 right 一定有一个已经结束了
    while (left <= mid) {
        temp[i] = num[left];
        i++;
        left++;
    }
    while (right <= r) {
        temp[i] = num[right];
        right++;
        i++;
    }
    for (int i = 0; i < len; i++) {
        num[l + i] = temp[i];
    }
    temp.clear();
}

// 分解部分
void MergeSort(vector<int>& num, int l, int r) {  // 左右端点均包括
    // 递归处理，有点类似回溯，后序遍历，某一个根节点，左端处理好，右端处理好，然后将左右两端进行合并操作
    if (l == r) return;
    int mid = (r - l) / 2 + l;
    MergeSort(num, l, mid); // 注意 包括 [l, mid] 
    MergeSort(num, mid + 1, r); // 因为左右都包括 [l, r] 所以使用 mid + 1 作为左边
    Merge(num, l, r, mid);
}


// 迭代解法 ： 我们将递归转成迭代的方式，就是枚举每一个间隔 1, 2, 4, 8, 16 .....
void MergeSort1(vector<int>& num, int l, int r) {
    // 可以直接利用上面的 Merge 操作
    int len = num.size();
    for (int step = 1; step <= len; step = step * 2) {
        int offset = step + step; // offset 是总长度，每次遍历的总长度
      	// step 是一半的长度,可以说说是中间结点
        for (int index = 0; index < len; index += offset) {
            Merge(num, index, min(len - 1, index + offset - 1), min(len - 1, index + step - 1));  // 注意这个 min 取最小值，同时这个-1 的边界情况处理!!!
            // 仔细思考一下为什么是这样的
        }
    }
}
```



```c++
// 链表的归并排序

ListNode* split(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head -> next; // 普通写法都是 fast = head; 这里为啥是 head -> next 呢？ 因为这是为了方便我们将链表切断！！！
    while (fast != nullptr && fast -> next != nullptr) {
        slow = slow -> next;
        fast = fast -> next -> next;
    }
    ListNode* node = slow -> next;
    slow -> next = nullptr;
    return node; // 这个 slow 指针就是我们希望求解的中间节点
}

// 合并两个链表的递归解法.
ListNode* Merge_recursive(ListNode* left, ListNode* right) {
  	if (list1 == nullptr) return list2;
    if (list2 == nullptr) return list1;
    if (list1 -> val < list2 -> val) {
        list1 -> next = mergeTwoLists(list1 -> next, list2);
        return list1;
    }
    list2 -> next = mergeTwoLists(list1, list2 -> next);
    return list2;
}

// 合并两个链表的非递归解法
ListNode* Merge(ListNode* left, ListNode* right) {
    ListNode* node = new ListNode(-1);
    ListNode* res = node;
    while (left && right) {
        if (left -> val < right -> val) {
            // node -> next = new ListNode(left -> val);  // 这样需要额外的空间，所以不能这样写
            // 可以下面这种写法，不需要申请额外的空间：
            node -> next = left;
            left = left -> next;
        } else {
            // node -> next = new ListNode(right -> val);
            node -> next = right;
            right = right -> next;
        }
        node = node -> next;
    }
    node -> next = left != nullptr ? left : right;
    return res -> next;
}
ListNode* sortList(ListNode* head) {

    // 不使用额外的空间,归并排序，但是归并排序需要额外的空间啊，链表是不需要额外的空间的
    // 同时可以考虑使用快速排序的方式
    // 解法二： 归并排序,默写一下常规的归并排序

    // 如何找到中间节点，可以使用快慢指针的方式找到中间节点

    if (!head || !head -> next) return head;
    ListNode* head1 = head;
    ListNode* head2 = split(head);
    ListNode* first = sortList(head1);
    ListNode* second = sortList(head2);
    return Merge(first, second);
}
```



```cpp
// 归并排序的另外一种思路，划分和合并不是分开的了，是合并在一起的，合并在一起做
// 可以求特定条件的逆序对，和可以归并求解的题目
// 因为使用的是分治算法，所以都是从小区间到大区间开始处理的，所以小区间处理完再处理大区间，我们需要处理各个区间之间的关系，这些关系是互不影响的。这也是分治的优点
// leetcode 327 493
int solve(vector<int>& nums, int left, int right) {
    if (left == right) return 0;
    int mid = (right - left) / 2 + left;
    int n1 = solve(nums, left, mid);
    int n2 = solve(nums, mid + 1, right);
    int res = n1 + n2;

    // 下面是执行我们需要的操作代码，下面这部分代码可以随着题目需求而更改
  	// 下面这一部分就是特殊执行的代码
    int l = left, r = mid + 1;
    while (l <= mid && r <= right) {
        if ((long) nums[l] <= (long) 2 * nums[r]) l++;
        else {
            res += (mid - l + 1);
            r++;
        }
    }

    // 下面这部分就是你执行的是归并排序部分，将其合并成有序的.
    l = left, r = mid + 1;
    vector<int>temp(right - left + 1);
    int k = 0;
    while (l <= mid && r <= right) {
        if (nums[l] <= nums[r]) {
            temp[k] = nums[l];
            l++;
        } else {
            temp[k] = nums[r];
            r++;
        }
      	k++;
    }
    while (l <= mid) {
        temp[k] = nums[l];
        k++;
        l++;
    }
    while (r <= right) {
        temp[k] = nums[r];
        k++;
        r++;
    }
    for (int i = 0; i < temp.size(); i++) {
      	nums[i + left] = temp[i];
    }
    	return res;
  }
int reversePairs(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    return solve(nums, 0, n - 1);
}
```







##### 冒泡排序

```c++
#include<bits/stdc++.h>

using namespace std;

void bub_sort(vector<int>& nums) {
    for (int i = 0; i < nums.size() - 1; i++) {
        for (int j = 0; j < nums.size() - 1 - i; j++) {  // 我们顶部的元素一个一个确定下来了，所以顶部元素需要 -i
            if (nums[j] > nums[j + 1]) { // 每次确定顶部的一个元素
                swap(nums[j], nums[j + 1]);
            }
        }
    }
}

void bub_sort1(vector<int>& nums) {
    for (int i = 0; i < nums.size(); i++) {
        for (int j = nums.size() - 1; j > i; j--) {  // 从后往前，然后每次确定底部的最小的元素
            if (nums[j] < nums[j - 1]) { // 交换当前和前一个元素
                swap(nums[j], nums[j - 1]);
            }
        }
    }
}

int main() {
    srand((unsigned)time(NULL));
    vector<int>nums, nums1;
    for (int i = 0; i < 1000; i++) {
        int num = rand() % 100;
        nums.push_back(num);
        nums1.push_back(num);
    }
    sort(nums1.begin(), nums1.end());
    bub_sort1(nums);
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != nums1[i]) cout << "ERROR!!!" << endl;
    }
    cout << "FINE!!!" << endl;
    return 0;
}
```





##### 堆排序

```c++
#include<bits/stdc++.h>

using namespace std;

void adjust(vector<int>&nums, int len, int idx) {
    int left = idx * 2 + 1;
    int right = idx * 2 + 2;
    int max_idx = idx;
    if (left < len && nums[left] > nums[idx]) max_idx = left;
    if (right < len && nums[right] > nums[max_idx]) max_idx = right;
    if (idx != max_idx) {
        swap(nums[idx], nums[max_idx]);
        adjust(nums, len, max_idx);
    }
}

void solve(vector<int>&nums) {
  	// 下面只是调整堆结构，但是并没有让 vector 中的元素都变成有序的
    int n = nums.size();
    for (int i = (n - 1) / 2; i >= 0; i--) {
        adjust(nums, n, i);
    }
  	// 上面这个步骤并没有让数组有序，只不过数组中的元素是符合堆的结构
  	// 将元素放在末尾，然后再调整这个堆，让最大的元素放在vector 的第一个位置，然后交换,让这个数组变得有序
    for (int i = n - 1; i >= 0; i--) {
        swap(nums[0], nums[i]);
        adjust(nums, i, 0);
    }
}

int main() {
    vector<int>nums, nums1;
    srand((unsigned)time(NULL));
    int n = 20;
    for (int i = 0; i < n; i++) {
        int num = rand() % n;
        nums.push_back(num);
        nums1.push_back(num);
    }
    solve(nums);
    sort(nums1.begin(), nums1.end());
    for (int i = 0; i < n; i++) {
        if (nums[i] != nums1[i]) cout << "ERROR!!!!" << endl;
    }
    cout << "Fine ok!" << endl;
    return 0;
}
```



##### 选择排序

```c++
// 每一次内部 for 循环找到第 i 个位置的最终的元素值
// 堆排序就是基于选择排序的
// 每一次循环找到一个元素并将其放入到指定的最终位置
void select_sort(vector<int>& nums) {
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i; j < nums.size(); j++) {
            if (nums[i] > nums[j]) { // 永远和 第 i 个元素做比较操作
                swap(nums[i], nums[j]);
            }
        }
    }
}
```





##### 插入排序

```c++
void insertsort(vector<int>& nums) {
  	// 每一次排序没法确定其最终的位置
    int n = nums.size();
    if (n <= 1) return;
    for (int i = 1; i < n; i++) {
        int key = nums[i]; // 需要比较的元素
        int j = i - 1;
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];
            j--;
        }
        nums[j + 1] = key; // 注意这个是 j + 1,这个就是插入操作
    }
}
```





##### 基数排序

```cpp
int maximumGap(vector<int>& nums) {
    // 基数排序，学习一下基数排序是如何实施的
  	// 时间复杂度 ： O(n) 空间复杂度 ： O(n)
    int n = nums.size();
    if (n == 1) return 0;
    int exp = 1;
    int max_val = -1;
    for (auto c : nums) max_val = max(max_val, c);
    while (max_val >= exp) {
        vector<int>cnt(10);
        for (int i = 0; i < nums.size(); i++) {
            int digit = (nums[i] / exp) % 10;
            cnt[digit]++;
        }
        for (int i = 1; i < 10; i++) {
          	cnt[i] += cnt[i - 1];  // 这个就是为了下一步的操作，就是赋值，一个一个有序的赋值
        }
        vector<int>buf(n);
        for (int i = n - 1; i >= 0; i--) {  // 注意这个需要从后向前，因为需要确保之前的大的在后面，当
          // 当前这个元素值是相同的时候，前一位需要从小到大排序
            int digit = (nums[i] / exp) % 10;
            buf[cnt[digit] - 1] = nums[i];
            cnt[digit]--;
        }
        exp *= 10;
        copy(buf.begin(), buf.end(), nums.begin());
    }
  	// 截止到目前，已经完成桶排序了， nums 中的元素就是已经排序好的数组
    int res = 0;
    for (int i = 1; i < nums.size(); i++) {
      	res = max(res, nums[i] - nums[i - 1]);
    }
    return res;
}
```





##### 桶排序

```cpp
// time complexity is : O(n), space complexity is O(n)
int maximumGap(vector<int>& nums) {
    // bucket size
    int n = nums.size();
    if (n == 1) return 0;
    int max_val = -1;
    int min_val = INT_MAX;
    for (auto& c : nums) {
        min_val = min(min_val, c);
        max_val = max(max_val, c);
    }
    // how to put the value into the suitable bucket
    int num = (max_val - min_val) / (n - 1); // this represent the size in every bucket
    if (num == 0) {
        num = 1; // avoid too many number but most of them is same
    }
    if (min_val == max_val) return 0;
    int bucket_size = (max_val - min_val) / num + 1; // how many bucket in total
    vector<PII>vec(bucket_size, PII(-1, -1));
    for (int i = 0; i < n; i++) {
        // the nums[i] should put which bucket?
        int idx = (nums[i] - min_val) / num;
        if (vec[idx].first == -1) {  // this represent the first and second both are not initialize
            vec[idx].first = nums[i];
            vec[idx].second = nums[i];
        } else {
            vec[idx].first = min(nums[i], vec[idx].first);
            vec[idx].second = max(nums[i], vec[idx].second);
        }
    }
    // the end of the bucket sort
    int res = 0;
    int pre = -1;
    for (int i = 0; i < bucket_size; i++) {
        if (vec[i].first == -1) continue;
        if (pre != -1) {
            res = max(res, vec[i].first - vec[pre].second);
        }
        pre = i;
    }
    return res;
}
```







#### 其他

##### 记忆化搜索模板

* leetcode 464

	```cpp
	bool solve(int range, int target, unordered_map<int, bool>& mp, int used) {
	    if (mp.find(used) != mp.end()) return mp[used]; // 如果某个数字访问过，表示可能性确定了，不会改变了，所以直接返回就可以了.
	  	// 上面不是终止条件，上面这个只是简化操作，节约遍历次数
	
	    for (int i = 0; i < range; i++) {
	        int cur = (1 << i);
	        if ((cur & used) == 0) {
	          // 这个数字没有被选择过
	          	// 递归一定要终止条件，这个终止条件就是 target <= i + 1
	            if (target <= i + 1 || !solve(range, target - i - 1, mp, used | cur)) {
	              	// 这个就是记忆化搜索的模板，我们只需要找到就可以了，所以在当中找到存在 false 就可以了。
	              	// target <= i + 1 是一个递归终止条件，方便最后一次递归出去.
	                mp[used] = 1;
	                return true;
	            }
	        }
	    }
	    mp[used] = 0;
	    return 0;
	}
	```

* leetcode 139

```cpp
bool solve(string& s, unordered_set<string>& st, unordered_map<int, bool>& vis, int idx) {
    if (vis.find(idx) != vis.end()) return vis[idx]; // 表示已经确定
    for (int i = idx; i < s.size(); i++) {
        string str = s.substr(idx, i - idx + 1);
        if (st.find(str) != st.end()) {
            // 下面的  i >= s.size() - 1是递归出口代码,防止一直没法递归出去,需要有这个代码
            if (i >= s.size() - 1 || solve(s, st, vis, i + 1)) {
                vis[idx] = 1;
                return true;
            }
        }
    }
    vis[idx] = 0;
    return 0;
}
```



* 需要习惯将双指针和 hash 表结合起来，以及前缀和和 hash 表结合起来。

* Leetcode 312

* ```cpp
	int solve(vector<int>& nums, vector<vector<int>>& dp, int l, int r) {
	    if (l > r) return 0;
	    // if (l == r) return nums[l];  
	    if (dp[l][r] > 0) return dp[l][r];
	    int num = 0;
	    for (int k = l; k <= r; k++) {
	        int left = solve(nums, dp, l, k - 1);
	        int right = solve(nums, dp, k + 1, r);
	        // int res1 = (k == l) ? 1 : nums[k - 1];
	        // int res2 = (k == r) ? 1 : nums[k + 1];
	        // 第 k 个气球是最后一个爆炸的.
	        int temp = left + right + nums[l - 1] * nums[r + 1] * nums[k];  // 最后一个戳破的气球是 k 
	        num = max(num, temp);
	    }
	  	// 记忆化搜索， 最后将 [l][r] 的结果存起来
	    dp[l][r] = num;
	    return dp[l][r];
	}
	int maxCoins(vector<int>& nums) {
	    int n = nums.size();
	    // unordered_map<int, int>mp;
	    // for (int i = 0; i < nums.size(); i++) {
	    //     mp[i] = nums[i];
	    // }
	
	    // 记忆化搜索，先搜索一波，我们不考虑删除的情况，我们直接返回左右区间的结果
	    nums.insert(nums.begin(), 1); // 解决边界问题
	    nums.push_back(1);
	    vector<vector<int>>dp(n + 2, vector<int>(n + 2));
	    return solve(nums, dp, 1, n);
	
	    // dp 求解
	    for (int len = 1; len <= n; len++) {
	        for (int left = 1; left + len - 1 <= n; left++) {
	            int right = left + len - 1;
	            if (len == 1) {
	            	  dp[left][left] = nums[left - 1] * nums[left] * nums[left + 1];
	            } else {
	              // len > 1
	                for (int k = left; k <= right; k++) { // 因为我们是从小区间到大区间一步一步求解的
	                 	 dp[left][right] = max(dp[left][right], dp[left][k - 1] + dp[k + 1][right] + nums[k] * nums[left - 1] * nums[right + 1]);  // 注意第 k 个数据是最后一个求解的，所以其结果是 left - 1 * right + 1 * k 
	                	}
	            	}
	          }
	    }
	    return dp[1][n];
	}
	```

* 

##### 移除元素 — 双指针

* 移除的元素可以是指定的元素 val 或者是空格之类的，我们采用的是覆盖的方式，双指针的方式



```c++
int removeElement(vector<int>& nums, int val) {
    int n = nums.size();
    int l, r;
    for (l = 0, r = 0; r < n; r++) {
        if (nums[r] != val) {  // 只考虑右边的情况，右边只要不是val就赋值
            nums[l] = nums[r];
            l++;
        }
    }
    return l;
}
```



##### 双指针模板- 滑动窗口（没法解决存在无序负数的情况）

* 求数组连续区间的特性
* **没法求存在负数的情况（但是数组是有序的，存在负数还是可以解的）**
* 负数一般使用前缀和求解

```c++
// 数组连续区间的性质
int solve(vector<int>& nums, int target) {
    int l = 0;
    int res = 0;
    int sum = 0;
    for (int r = 0; r < nums.size(); r++) { // 我 r 每一次都向右移动一次
        sum += nums[r];
        while (l <= r && sum > target) { // 先进行去除不符合条件的元素，之后再进行计算的操作
            sum -= nums[l];
            l++;
        }
        // 这里可能 l > r ,即 l = r + 1
        res = max(r - l + 1, res); // 具体问题具体分析，也可能在 while 循环内部
    }
    return res;
}
```



```cpp
// 双指针，可能出现负数，但是有序的数组存在负数也可以使用双指针，当有序数组使用双指针，可以从头和从尾部遍历，非常的方便
vector<int> twoSum(vector<int>& numbers, int target) {
    int n = numbers.size();
    // double pointers
    // int n = numbers.size();
    int res = 0;
    for (int i = 0, j = n - 1; i < j;) {
        int num = numbers[i] + numbers[j];
        if (num == target) return {i + 1, j + 1};
        else if (num > target) j--;
        else i++;
    }
    return {};
}
```

* 两个数组上的双指针，目的是的两个数组元素差尽可能的接近

```cpp
```









##### 存在负数双指针没法解决，前缀和 + hash 求解

[剑指 Offer II 010. 和为 k 的子数组](https://leetcode.cn/problems/QTMn0o/)

```cpp
int subarraySum(vector<int>& nums, int k) {
    // 双指针不适用存在负数的情况，存在负数需要使用前缀和以及 hash 表求解
    // 充分利用前缀和的性质，非常好的一道题目,因为前缀和是一个连续的东西，所以一定要注意思考
 		// 通常使用前缀和 + hash 求解需要将 mp[0] = 1
  	// 同时注意这种题通常求解连续的数组
  	// 注意这种题如何设置合适的哨兵也非常的关键
    unordered_map<int, int> mp;
    mp[0] = 1;
    int res = 0;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        if (mp.find(sum - k) != mp.end()) {
            res += mp[sum - k];
        }
        mp[sum]++;
    }
    return res;
}
```

[面试题 17.05.  字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/)(前缀和求解，注意哨兵的设置)

```cpp
class Solution {
public:
    vector<string> findLongestSubarray(vector<string>& array) {
        // 使用前缀和的思想，是一种非常常见的前缀和题目，注意哨兵的建立
        int n = array.size();
        vector<int>nums(n);

        for (int i = 0; i < n; i++) {
            if (isdigit(array[i][0])) {
                nums[i] = 1;
            } else {
                nums[i] = -1;
            }
        }

        unordered_map<int, int>mp;  // 存储的是 sum, idx
        int sum = 0;
        mp[0] = -1;  // 注意这里设置成 -1 这样方便后面的计算，算是一个哨兵作用
        int left = -1, right = -1;
        int length = 0;
        vector<string>res;

        for (int i = 0; i < n; i++) {
            sum += nums[i];
            if (mp.find(sum) != mp.end()) {
                int gap = i - mp[sum];
                if (gap > length) {
                    left = mp[sum];
                    right = i;
                    length = gap;
                }
            } else {
                mp[sum] = i;
            }
        }
        
        for (int i = left + 1; i <= right; i++) {
            res.push_back(array[i]);
        }

        return res;
    }
};
```









##### 单调栈

* 注意在连续弹栈的时候一定是使用  while() 循环而不是 if 进行相应的操作

```c++
// 基本的单调增模板， The next greater num  注意下一个更大的值，不是数组后面最大的值
// 这个保证的是局部的单调递增（res[i]），当然在整个栈中的数据也是单调递增的
void solve(vector<int>&nums) {
    // 每一个元素只进栈一次，最多出一次栈，所以总的时间复杂度： O(n)
    int n = nums.size();
    vector<int>res(n);
    stack<int>st;
    for (int i = n - 1; i >= 0; i--) {  // 这样是单调递增的栈：即 栈中随着 i 变大 nums[i] 更大的存在栈中
        // for (int i = 0; i < n; i++) {} 这样就是单调减栈,也就是 The before greater number
        while (!st.empty() && nums[i] >= st.top()) {
            st.pop();
        }
        res[i] = st.empty() ? -1 : st.top(); // 这里往往根据题意的不同，可适当修改，可以是数组索引下标之类的。
        st.push(nums[i]);  // 注意这一步不能和上一步调换，因为调换了就可能出错了
    }
}


// 单调递减栈，同时先输出的是数组后面的元素，上面的这种写法是先输出数组前面的元素
// 准确说这个是针对的是 leetcode 1124 这一题的，我们是需要输出的是单减的小于 0 的序列
// 下面这个情况比较的特殊,这个注意需要的是小于 0 的单调递减栈，因为第一个元素是0
void solve(vector<int>& nums) {
    stack<int>st;
    // 下面也可以是以第一个元素开始的单调递减栈，或者单调递增栈，都是相对于第一个元素而言
    for (int i = 0; i < nums.size(); i++) {
        if (st.size() == 0 || pre_sum[st.top()] > pre_sum[i]) {
            st.push(i);
        }
    }
}
```





##### 单调队列 （解决滑动窗口）

```c++
class Queue {
public:
    void push(int n) {
        while (!dq.empty() && dq.back() < n) {
            dq.pop_back();
        }
        dq.push_back(n); // 这样这个就是最大的了,比他小的都被弹出去了
    }
    int max() {
        return dq.front();
    }
    void pop(int n) {
        if (!dq.empty() && dq.front() == n){  // 弹出去的元素只有在队头的可能性，因为队头是最先进入
        // 或者是之后进入进行覆盖了，那就不存在这个 n 了 啥也不需要做了,队头弹出有先后顺序的
            dq.pop_front();
        }
    }
private:
    deque<int>dq;  // dq 的一系列操作都是 O(1) 的  双端队列
};
```



##### 字符串处理-双指针

```c++
bool allZero(vector<int>& nums) {
    for (auto c : nums) {
        if (c != 0) return false;
    }
    return true;
}
vector<int> findAnagrams(string s, string p) {
    vector<int>res;
    if (s.size() < p.size()) return res;
    vector<int>vis(26);
    for (int i = 0; i < p.size(); i++) {
        vis[p[i] - 'a']++;
    }
    for (int i = 0; i < p.size(); i++) {  /// 注意需要在 for 循环外面先只走右指针
        vis[s[i] - 'a']--;
    }
    if (allZero(vis)) {
        res.push_back(0);
    }
    for (int i = p.size(); i < s.size(); i++) {
        vis[s[i] - 'a']--;
        vis[s[i - p.size()] - 'a']++;
        if (allZero(vis)) {
            res.push_back(i - p.size() + 1);
        }
    }
    return res;
}
```



##### 贪心求解 & 差分（上下车问题）









##### Pre_sum 求法

###### 法一

```cpp
vector<int>solve(vector<int>& nums) {
    int n = nums.size();
    vector<int>pre_sum(n);
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            pre_sum[i] = nums[i];
        } else {
            pre_sum[i] = pre_sum[i - 1] + nums[i];
        }
    }
    return pre_sum;
}
// 1 3 6 10 15 21 28 36 45 
```

*  [left, right] 的区间和是： pre_sum[right] - pre_sum[left - 1]
* 常用左开右闭表示数组 (left, right] , 此时子数组的和是 ： pre_sum[right] - pre_sum[left], 子数组长度  right - left
*  [left, right] 的区间和是： sum = pre_sum[right] - pre_sum[left] + nums[left]



###### 法二

```cpp
vector<int>solve1(vector<int>& nums) {
    int n = nums.size();
    vector<int>pre_sum(n + 1);
    for (int i = 0; i < n; i++) {
        pre_sum[i + 1] = pre_sum[i] + nums[i];
    }
    return pre_sum;
}
// 0 1 3 6 10 15 21 28 36 45 
```

* 常用左闭右开表示数组 [left, right) , 此时子数组的和是 ： pre_sum[right] - pre_sum[left], 子数组长度  right - left
* [left, right] 求和公式： pre_sum[right + 1] - pre_sum[left]







##### 回溯总结

* 排序是剪枝的一种方式 .  **原则：想方设法的剪枝操作**

* ```cpp
	unordered_set<string>st // 去重的方式
	if (int i = idx; i < num.size(); i++) {
	  	if (i != idx && nums[i - 1] == nums[i]) continue; // 剪枝手段，因为只有当其 idx 作为第一个被选择就可以了，当其不是第一个的时候不要选择，因为一定会重复,去重的手段之一
	}
	```

* 全排列需要使用 vis 数组判断当前是否被遍历过，组合数不需要 vis 数组，因为不会向 idx 前面的数据遍历。全排列是会从头开始遍历

* ```cpp
	for (int i = 0; i < num.size(); i++) { // 注意这个 i 从 0 开始,因为是全排列，可能回过头遍历
	  	// 全排列
	  	if (i > 0 && nums[i] == nums[i - 1] && vis[i - 1] == 0) continue; // 去重,因为之后可能选择到这个数据
	  	if(vis[i]) continue; // 遍历过了，过
	}
	
	for (int i = idx; i < nums.size(); i++) { // 这个 i 不需要从头再次遍历，所以 i = idx
	  	// 组合数
	  	if (i > idx && nums[i] == nums[i - 1]) continue; // 剪枝
	   	// 无 vis 数组
	}
	```

* 



##### 二分总结

* [面试题 10.03. 搜索旋转数组](https://leetcode.cn/problems/search-rotate-array-lcci/)

* [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

```cpp
// 10.03 注意二分一般和 !!!右边比较!!!
// 注意有重复元素，需要进行去重操作
// 这是旋转数组的例题。

class Solution {
public:
    int search(vector<int>& arr, int target) {
        int n = arr.size();
        int l = 0, r = n - 1;
        if (arr[0] == target) return 0; // 这个必须提前判断，因为二分没法求解 [1, 1, 1,2, 1, 1]
        // 这种测试样例，所以需要特判

        while (l <= r) {
            int mid = (r - l) / 2 + l;
            if (arr[mid] == target) {
                while (mid >= 0 && arr[mid] == target) {
                    mid--;
                }
                return mid + 1;
            } else if (arr[mid] > arr[r]) { // 通常都是和右边进行比较，然后找出其在哪个区间中，最终找出数字的下标
                if (target >= arr[l] && target < arr[mid]) r = mid;
                else l = mid + 1;
            } else if (arr[mid] < arr[r]){
                if (target > arr[mid] && target <= arr[r]) l = mid + 1;	// arr[mid] 和 target 一定不能带等于号，否则上面 arr[mid] == target 白判断了
                else r = mid;
            } else {
                r--;  // 注意这个需要进行的去重的操作，避免越过符合条件的数字了
            }
        }

        return -1;
    }
};

// 33. 搜索旋转排序数组
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l <= r) {
            int mid = (r - l) / 2 + l;
            if (nums[mid] == target) return mid;
            if (nums[mid] > nums[r]) {
                if (target >= nums[l] && target < nums[mid]) r = mid - 1;
                else l = mid + 1;
            } else {
                if (target > nums[mid] && target <= nums[r]) l = mid + 1;
                else r = mid - 1;  // 不存在 if (nums[mid] == nums[r]) 判断的时候需要 r = mid - 1 而不是 r = mid
            }
        }
        return -1;
    }
};


// 81. 搜索旋转排序数组 II
class Solution {
public:
    bool search(vector<int>& arr, int target) {
        int n = arr.size();
        int l = 0, r = n - 1;

        while (l <= r) {
            int mid = (r - l) / 2 + l;
            if (arr[mid] == target) return true;
            if (arr[mid] < arr[r]) {
                if (arr[mid] < target && target <= arr[r]) l = mid + 1;
                else r = mid;
            } else if (arr[mid] > arr[r]) {
                if (target >= arr[l] && target < arr[mid]) r = mid;
                else l = mid + 1;
            } else { // 需要单独判断等于号，那么就 r = mid 不需要的时候就是 r = mid - 1
                r--; // 跳过重复的元素
            }
        }
        return false;
    }
};


// 剑指 Offer 11. 旋转数组的最小数字
class Solution {
public:
    int minArray(vector<int>& numbers) {
        // 二分查找
        int l = 0, r = numbers.size() - 1;
        while (l <= r) {
            int mid = (r - l) / 2 + l;
            if (numbers[mid] > numbers[r]) {
                l = mid + 1;
            } else if (numbers[mid] < numbers[r]){
                r = mid;
            } else {
                r--;
            }
        }
        return numbers[l];
    }
};
```







##### 位运算小结

* `n & (n - 1)` : 删除 n 最后一位 1
* `n & (n + 1)` : n 最后一个 0 往后包括这个 0 ，结果都是 0
* `x ^ 1`: x 是偶数 : x + 1, x 是奇数 ：x - 1
* 







































### GO语言基本语法

#### Interface

* Golang的接口理解成多态，接口就是实现一个父类，派生类实现父类的虚函数，最后父类指针指向不同的派生类对象就会调用哪个派生类对象的虚函数，从而实现多态



#### Go 语言导入自己写的包，在非 src 文件夹下

![image-20220102151955799](/home/zhoubing/.config/Typora/typora-user-images/image-20220102151955799.png)



#### LOG 打印微秒级别

```go
log.SetFlags(log.LstdFlags | log.Lmicroseconds)
log.Print("Hello, playground")
// 2009/11/10 23:00:00.000000 Hello, playground
```



#### Go 语言基础知识

* 当使用的是结构体的时候，我们可以将其作为指针传入到参数中，当使用的是接口类型的时候，我们不能将其定义为指针进行传参，只能作为普通的值进行参数的传递









### OS

#### 并发和并行

![image-20211216004328655](/home/zhoubing/.config/Typora/typora-user-images/image-20211216004328655.png)



[用户级线程和内核级线程的区别](https://zhuanlan.zhihu.com/p/26279675)



![image-20211224213413951](/home/zhoubing/.config/Typora/typora-user-images/image-20211224213413951.png)





